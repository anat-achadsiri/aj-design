<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SA Screen Designer - UI Spec Tool</title>
    <!-- KeenIcons CSS from local assets -->
    <link rel="stylesheet" href="assets/plugins/global/plugins.bundle.css">
    <style>
        /* Theme Variables */
        :root {
            /* Default Theme */
            --primary-color: #3b82f6;
            --primary-hover: #2563eb;
            --button-bg: #f8fafc;
            --button-primary-bg: #0ea5e9;
            --button-success-bg: #22c55e;
            --button-danger-bg: #ef4444;
            --table-header-bg: #e0f2fe;
            --table-header-border: #7dd3fc;
            --table-header-color: #0369a1;
            --tab-active-bg: #e0f2fe;
            --tab-active-color: #0369a1;
            --tab-active-border: #7dd3fc;
            --input-border: #cbd5e1;
            --panel-header-bg: #f1f5f9;
            --label-color: #1e293b;
        }

        /* AJ Theme - Based on Spec screenshots */
        [data-theme="aj"] {
            --primary-color: #0891b2;
            --primary-hover: #0e7490;
            --button-bg: #f0fdfa;
            --button-primary-bg: #14b8a6;
            --button-success-bg: #10b981;
            --button-danger-bg: #f43f5e;
            --table-header-bg: #ccfbf1;
            --table-header-border: #5eead4;
            --table-header-color: #0f766e;
            --tab-active-bg: #ccfbf1;
            --tab-active-color: #0f766e;
            --tab-active-border: #5eead4;
            --input-border: #99f6e4;
            --panel-header-bg: #f0fdfa;
            --label-color: #134e4a;
        }

        /* Blue Theme */
        [data-theme="blue"] {
            --primary-color: #2563eb;
            --primary-hover: #1d4ed8;
            --button-bg: #eff6ff;
            --button-primary-bg: #3b82f6;
            --button-success-bg: #22c55e;
            --button-danger-bg: #ef4444;
            --table-header-bg: #dbeafe;
            --table-header-border: #93c5fd;
            --table-header-color: #1e40af;
            --tab-active-bg: #dbeafe;
            --tab-active-color: #1e40af;
            --tab-active-border: #93c5fd;
            --input-border: #93c5fd;
            --panel-header-bg: #eff6ff;
            --label-color: #1e3a8a;
        }

        /* Purple Theme */
        [data-theme="purple"] {
            --primary-color: #7c3aed;
            --primary-hover: #6d28d9;
            --button-bg: #f5f3ff;
            --button-primary-bg: #8b5cf6;
            --button-success-bg: #22c55e;
            --button-danger-bg: #ef4444;
            --table-header-bg: #ede9fe;
            --table-header-border: #c4b5fd;
            --table-header-color: #5b21b6;
            --tab-active-bg: #ede9fe;
            --tab-active-color: #5b21b6;
            --tab-active-border: #c4b5fd;
            --input-border: #c4b5fd;
            --panel-header-bg: #f5f3ff;
            --label-color: #4c1d95;
        }

        /* Gray Theme */
        [data-theme="gray"] {
            --primary-color: #475569;
            --primary-hover: #334155;
            --button-bg: #f8fafc;
            --button-primary-bg: #64748b;
            --button-success-bg: #22c55e;
            --button-danger-bg: #ef4444;
            --table-header-bg: #f1f5f9;
            --table-header-border: #cbd5e1;
            --table-header-color: #334155;
            --tab-active-bg: #e2e8f0;
            --tab-active-color: #334155;
            --tab-active-border: #94a3b8;
            --input-border: #cbd5e1;
            --panel-header-bg: #f1f5f9;
            --label-color: #1e293b;
        }

        /* Metronic Theme - KeenThemes Style */
        [data-theme="metronic"] {
            --primary-color: #1b84ff;
            --primary-hover: #056ee9;
            --button-bg: #f9f9f9;
            --button-primary-bg: #1b84ff;
            --button-success-bg: #17c653;
            --button-danger-bg: #f8285a;
            --button-warning-bg: #f6b100;
            --table-header-bg: #f9f9f9;
            --table-header-border: #e9e9e9;
            --table-header-color: #252f4a;
            --tab-active-bg: #1b84ff;
            --tab-active-color: #ffffff;
            --tab-active-border: #1b84ff;
            --input-border: #dbdfe9;
            --panel-header-bg: #f9f9f9;
            --label-color: #252f4a;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            overflow: hidden;
        }

        /* Layout */
        .app-container {
            display: flex;
            height: 100vh;
        }

        /* Sidebar - Component Palette */
        .sidebar {
            width: 240px;
            background: #1e293b;
            color: white;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 16px;
            background: #0f172a;
            border-bottom: 1px solid #334155;
        }

        .sidebar-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .component-group {
            padding: 12px;
            border-bottom: 1px solid #334155;
        }

        .component-group h3 {
            font-size: 11px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            margin-bottom: 8px;
            letter-spacing: 0.5px;
        }

        .component-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            background: #334155;
            border-radius: 6px;
            cursor: grab;
            transition: all 0.2s;
            font-size: 13px;
        }

        .component-item:hover {
            background: #475569;
            transform: translateX(4px);
        }

        .component-item:active {
            cursor: grabbing;
        }

        .component-item .icon {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
        }

        /* Main Area */
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Toolbar */
        .toolbar {
            display: flex;
            align-items: center;
            padding: 8px 16px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            gap: 8px;
        }

        .toolbar-group {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 0 8px;
            border-right: 1px solid #e2e8f0;
        }

        .toolbar-group:last-child {
            border-right: none;
        }

        .toolbar-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 36px;
            padding: 0;
            border: 1px solid #e2e8f0;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 18px;
            color: #475569;
            transition: all 0.2s;
        }

        .toolbar-btn:hover {
            background: #f1f5f9;
            border-color: #cbd5e1;
        }

        .toolbar-btn.primary {
            background: #3b82f6;
            color: white;
            border-color: #3b82f6;
        }

        .toolbar-btn.primary:hover {
            background: #2563eb;
        }

        .toolbar-btn.danger {
            color: #dc2626;
            border-color: #fecaca;
        }

        .toolbar-btn.danger:hover {
            background: #fef2f2;
        }

        .screen-name-input {
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            width: 200px;
        }

        .screen-name-input:focus {
            outline: none;
            border-color: #3b82f6;
        }

        /* Canvas Area */
        .canvas-container {
            flex: 1;
            overflow: auto;
            padding: 24px;
            background: #e2e8f0;
        }

        .canvas {
            background: white;
            min-width: 400px;
            min-height: 300px;
            position: relative;
            border: 2px dashed #cbd5e1;
            border-radius: 8px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding-bottom: 50px;
            padding-right: 50px;
            transition: margin 0.2s ease;
        }

        .canvas.with-rulers {
            margin-left: 25px;
            margin-top: 25px;
        }

        /* Canvas Resize Handles */
        .canvas-resize-handle {
            position: absolute;
            background: #3b82f6;
            border-radius: 2px;
            z-index: 100;
        }

        .canvas-resize-handle.right {
            right: -4px;
            top: 50%;
            transform: translateY(-50%);
            width: 8px;
            height: 40px;
            cursor: e-resize;
        }

        .canvas-resize-handle.bottom {
            bottom: -4px;
            left: 50%;
            transform: translateX(-50%);
            width: 40px;
            height: 8px;
            cursor: s-resize;
        }

        .canvas-resize-handle.corner {
            right: -6px;
            bottom: -6px;
            width: 12px;
            height: 12px;
            cursor: se-resize;
            border-radius: 3px;
        }

        .canvas.drag-over {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        /* Marquee Selection */
        .marquee-selection {
            position: absolute;
            border: 2px dashed #3b82f6;
            background: rgba(59, 130, 246, 0.1);
            pointer-events: none;
            z-index: 1000;
            display: none;
        }

        /* Multi-selected components */
        .dropped-component.multi-selected {
            outline: 2px solid #8b5cf6;
            outline-offset: 2px;
        }

        /* Grid Overlay */
        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 0;
            display: none;
        }

        .grid-overlay.visible {
            display: block;
        }

        .grid-overlay.grid-small {
            background-image:
                linear-gradient(to right, rgba(200, 200, 200, 0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(200, 200, 200, 0.3) 1px, transparent 1px);
            background-size: 10px 10px;
        }

        .grid-overlay.grid-medium {
            background-image:
                linear-gradient(to right, rgba(180, 180, 180, 0.4) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(180, 180, 180, 0.4) 1px, transparent 1px),
                linear-gradient(to right, rgba(200, 200, 200, 0.2) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(200, 200, 200, 0.2) 1px, transparent 1px);
            background-size: 50px 50px, 50px 50px, 10px 10px, 10px 10px;
        }

        .grid-overlay.grid-large {
            background-image:
                linear-gradient(to right, rgba(150, 150, 150, 0.5) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(150, 150, 150, 0.5) 1px, transparent 1px),
                linear-gradient(to right, rgba(200, 200, 200, 0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(200, 200, 200, 0.3) 1px, transparent 1px);
            background-size: 100px 100px, 100px 100px, 20px 20px, 20px 20px;
        }

        /* Rulers */
        .ruler {
            position: absolute;
            background: #f1f5f9;
            z-index: 100;
            display: none;
        }

        .ruler.visible {
            display: block;
        }

        .ruler-horizontal {
            top: -25px;
            left: 0;
            right: 0;
            height: 25px;
            border-bottom: 1px solid #cbd5e1;
        }

        .ruler-vertical {
            top: 0;
            left: -25px;
            bottom: 0;
            width: 25px;
            border-right: 1px solid #cbd5e1;
        }

        .ruler-corner {
            position: absolute;
            top: -25px;
            left: -25px;
            width: 25px;
            height: 25px;
            background: #e2e8f0;
            border-right: 1px solid #cbd5e1;
            border-bottom: 1px solid #cbd5e1;
            z-index: 101;
            display: none;
        }

        .ruler-corner.visible {
            display: block;
        }

        /* Toolbar toggle button active state */
        .toolbar-btn.active {
            background: #3b82f6;
            color: white;
        }

        .toolbar-btn.active:hover {
            background: #2563eb;
        }

        /* Grid settings dropdown */
        .grid-settings {
            position: relative;
            display: inline-block;
        }

        .grid-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: white;
            border: 1px solid #e5e7eb;
            border-radius: 6px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            padding: 8px;
            z-index: 1000;
            display: none;
            min-width: 180px;
        }

        .grid-dropdown.visible {
            display: block;
        }

        .grid-dropdown label {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        .grid-dropdown label:hover {
            background: #f3f4f6;
        }

        .grid-dropdown hr {
            border: none;
            border-top: 1px solid #e5e7eb;
            margin: 6px 0;
        }

        .grid-dropdown .grid-size-option {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 13px;
        }

        .grid-dropdown .grid-size-option:hover {
            background: #f3f4f6;
        }

        .grid-dropdown .grid-size-option.active {
            background: #eff6ff;
            color: #3b82f6;
        }

        .snap-indicator {
            position: fixed;
            background: #3b82f6;
            z-index: 2000;
            pointer-events: none;
        }

        .snap-indicator.horizontal {
            height: 1px;
            left: 0;
            right: 0;
        }

        .snap-indicator.vertical {
            width: 1px;
            top: 0;
            bottom: 0;
        }

        /* Dropped Components */
        .dropped-component {
            position: absolute;
            cursor: move;
            min-width: 50px;
            min-height: 30px;
        }

        .dropped-component.selected {
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .dropped-component:hover {
            outline: 2px solid #93c5fd;
            outline-offset: 2px;
        }

        /* Drag Image Preview */
        .drag-image {
            position: absolute;
            pointer-events: none;
            z-index: 1000;
            opacity: 0.8;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            border-radius: 4px;
            outline: 2px solid #3b82f6;
            outline-offset: 2px;
        }

        .dropped-component.dragging {
            opacity: 0.3;
        }

        /* Resize Handles */
        .resize-handle {
            position: absolute;
            width: 8px;
            height: 8px;
            background: #3b82f6;
            border: 1px solid white;
            border-radius: 2px;
        }

        .resize-handle.se { right: -4px; bottom: -4px; cursor: se-resize; }
        .resize-handle.sw { left: -4px; bottom: -4px; cursor: sw-resize; }
        .resize-handle.ne { right: -4px; top: -4px; cursor: ne-resize; }
        .resize-handle.nw { left: -4px; top: -4px; cursor: nw-resize; }
        .resize-handle.e { right: -4px; top: 50%; transform: translateY(-50%); cursor: e-resize; }
        .resize-handle.w { left: -4px; top: 50%; transform: translateY(-50%); cursor: w-resize; }
        .resize-handle.n { top: -4px; left: 50%; transform: translateX(-50%); cursor: n-resize; }
        .resize-handle.s { bottom: -4px; left: 50%; transform: translateX(-50%); cursor: s-resize; }

        /* Component Styles - Using Theme Variables */
        .comp-label {
            display: block;
            width: 100%;
            height: 100%;
            font-size: 14px;
            color: var(--label-color);
            padding: 4px;
            box-sizing: border-box;
            line-height: 1.4;
            overflow: hidden;
            cursor: text;
            outline: none;
        }

        .comp-label:focus {
            background: #fefce8;
            border: 1px dashed #facc15;
            border-radius: 2px;
        }

        .comp-textbox {
            width: 100%;
            height: 100%;
            padding: 8px 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            background: white;
            box-sizing: border-box;
        }

        .comp-textbox[readonly] {
            pointer-events: none;
        }

        .comp-textarea {
            width: 100%;
            height: 100%;
            padding: 8px 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            background: white;
            resize: none;
            box-sizing: border-box;
        }

        .comp-textarea[readonly] {
            pointer-events: none;
        }

        .comp-datepicker {
            display: flex;
            align-items: center;
            width: 100%;
            height: 100%;
            gap: 8px;
        }

        .comp-datepicker input {
            flex: 1;
            height: 100%;
            padding: 8px 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            box-sizing: border-box;
        }

        .comp-datepicker input[readonly] {
            pointer-events: none;
        }

        .comp-datepicker .calendar-icon {
            width: 32px;
            height: 100%;
            min-height: 32px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--button-bg);
            cursor: pointer;
        }

        .comp-dropdown {
            width: 100%;
            height: 100%;
            padding: 0 32px 0 12px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            background-color: white;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            box-sizing: border-box;
        }

        .comp-dropdown[disabled] {
            pointer-events: none;
        }

        .comp-dropdown-wrapper {
            position: relative;
            display: block;
            width: 100%;
            height: 100%;
        }

        .comp-dropdown-wrapper::after {
            content: '';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-top: 6px solid #475569;
            pointer-events: none;
        }

        .comp-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
            color: var(--label-color);
        }

        .comp-checkbox input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .comp-radio {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            cursor: pointer;
            color: var(--label-color);
        }

        .comp-radio input {
            width: 16px;
            height: 16px;
            cursor: pointer;
            accent-color: var(--primary-color);
        }

        .comp-button {
            width: 100%;
            height: 100%;
            padding: 8px 20px;
            border: 1px solid var(--input-border);
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            background: var(--button-bg);
            box-sizing: border-box;
        }

        .comp-button.primary {
            background: var(--button-primary-bg);
            color: white;
            border-color: var(--button-primary-bg);
        }

        .comp-button.success {
            background: var(--button-success-bg);
            color: white;
            border-color: var(--button-success-bg);
        }

        .comp-button.danger {
            background: var(--button-danger-bg);
            color: white;
            border-color: var(--button-danger-bg);
        }

        .comp-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
        }

        .comp-table th {
            background: var(--table-header-bg);
            border: 1px solid var(--table-header-border);
            padding: 8px 12px;
            font-weight: 600;
            color: var(--table-header-color);
        }

        .comp-table td {
            border: 1px solid #e2e8f0;
            padding: 8px 12px;
            background: white;
        }

        .comp-tabs {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
        }

        .comp-tabs .tab-header {
            display: flex;
            border-bottom: 1px solid #e2e8f0;
        }

        .comp-tabs .tab-item {
            padding: 10px 20px;
            border: 1px solid #e2e8f0;
            border-bottom: none;
            background: #f8fafc;
            cursor: pointer;
            font-size: 14px;
            margin-right: -1px;
        }

        .comp-tabs .tab-item.active {
            background: var(--tab-active-bg);
            color: var(--tab-active-color);
            border-color: var(--tab-active-border);
            font-weight: 600;
        }

        .comp-tabs .tab-content {
            border: 1px solid #e2e8f0;
            border-top: none;
            padding: 16px;
            flex: 1;
            background: white;
            box-sizing: border-box;
        }

        .comp-panel {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: white;
            box-sizing: border-box;
        }

        .comp-panel .panel-header {
            padding: 12px 16px;
            background: var(--panel-header-bg);
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            font-size: 14px;
            color: var(--label-color);
        }

        .comp-panel .panel-body {
            padding: 16px;
            flex: 1;
        }

        .comp-title {
            display: block;
            width: 100%;
            height: 100%;
            font-size: 18px;
            font-weight: 600;
            color: var(--label-color);
            padding: 8px 4px;
            box-sizing: border-box;
            cursor: text;
            outline: none;
        }

        .comp-title:focus {
            background: #fefce8;
            border: 1px dashed #facc15;
            border-radius: 2px;
        }

        .comp-image {
            width: 100%;
            height: 100%;
            object-fit: contain;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            background: #f8fafc;
        }

        .comp-image-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px dashed #cbd5e1;
            border-radius: 4px;
            background: #f8fafc;
            color: #94a3b8;
            cursor: pointer;
        }

        .comp-image-placeholder:hover {
            border-color: #3b82f6;
            background: #eff6ff;
        }

        /* Theme Selector Styles */
        .theme-selector {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .theme-selector label {
            font-size: 13px;
            color: #64748b;
        }

        .theme-selector select {
            padding: 6px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 13px;
            background: white;
            cursor: pointer;
        }

        .theme-preview {
            display: flex;
            gap: 4px;
        }

        .canvas-size-controls {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .canvas-size-controls label {
            font-size: 13px;
            color: #64748b;
        }

        .canvas-size-controls input[type="number"] {
            padding: 6px 8px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 13px;
            text-align: center;
        }

        .canvas-size-controls span {
            color: #64748b;
            font-size: 13px;
        }

        .theme-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            border: 1px solid rgba(0,0,0,0.1);
        }

        .comp-icon-btn {
            width: 100%;
            height: 100%;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 16px;
            box-sizing: border-box;
        }

        .comp-icon-btn.edit { background: #dbeafe; color: #2563eb; }
        .comp-icon-btn.delete { background: #fee2e2; color: #dc2626; }
        .comp-icon-btn.view { background: #fef3c7; color: #d97706; }
        .comp-icon-btn.save { background: #d1fae5; color: #059669; }

        /* Annotation */
        .comp-annotation {
            position: relative;
        }

        .annotation-line {
            position: absolute;
            background: #3b82f6;
            height: 2px;
            transform-origin: left center;
        }

        .annotation-arrow {
            width: 0;
            height: 0;
            border-left: 8px solid #3b82f6;
            border-top: 5px solid transparent;
            border-bottom: 5px solid transparent;
            position: absolute;
            right: -8px;
            top: -4px;
        }

        .annotation-box {
            background: #fffbeb;
            border: 1px solid #fcd34d;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            color: #92400e;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Properties Panel */
        .properties-panel {
            width: 280px;
            background: white;
            border-left: 1px solid #e2e8f0;
            display: flex;
            flex-direction: column;
            flex-shrink: 0;
        }

        .properties-header {
            padding: 16px;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            font-size: 14px;
            color: #1e293b;
        }

        .properties-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .property-group {
            margin-bottom: 16px;
        }

        .property-group label {
            display: block;
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            margin-bottom: 4px;
            text-transform: uppercase;
        }

        .property-group input,
        .property-group select,
        .property-group textarea {
            width: 100%;
            padding: 8px 10px;
            border: 1px solid #e2e8f0;
            border-radius: 4px;
            font-size: 13px;
        }

        .property-group input:focus,
        .property-group select:focus,
        .property-group textarea:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .property-row {
            display: flex;
            gap: 8px;
        }

        .property-row .property-group {
            flex: 1;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .modal {
            background: white;
            border-radius: 12px;
            width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .modal-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 600;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 20px;
            cursor: pointer;
            color: #64748b;
        }

        .modal-body {
            padding: 20px;
            max-height: 60vh;
            overflow-y: auto;
        }

        .modal-footer {
            padding: 16px 20px;
            border-top: 1px solid #e2e8f0;
            display: flex;
            justify-content: flex-end;
            gap: 8px;
        }

        /* Hidden */
        .hidden {
            display: none !important;
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.15);
            z-index: 1000;
            min-width: 160px;
            padding: 4px 0;
        }

        .context-menu-item {
            padding: 8px 16px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .context-menu-item:hover {
            background: #f1f5f9;
        }

        .context-menu-item.danger {
            color: #dc2626;
        }

        .context-menu-divider {
            height: 1px;
            background: #e2e8f0;
            margin: 4px 0;
        }

        /* Toast notification */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            background: #1e293b;
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 2000;
            animation: slideIn 0.3s ease;
        }

        .toast.success {
            background: #059669;
        }

        .toast.error {
            background: #dc2626;
        }

        @keyframes slideIn {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Document Tabs Bar */
        .document-tabs-bar {
            display: flex;
            align-items: center;
            background: #1e293b;
            border-bottom: 1px solid #334155;
            min-height: 36px;
            padding: 0 8px;
            gap: 2px;
        }

        .document-tabs-container {
            display: flex;
            align-items: center;
            flex: 1;
            overflow-x: auto;
            gap: 2px;
        }

        .document-tabs-container::-webkit-scrollbar {
            height: 4px;
        }

        .document-tabs-container::-webkit-scrollbar-track {
            background: #334155;
        }

        .document-tabs-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 2px;
        }

        .document-tab {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #334155;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 13px;
            color: #94a3b8;
            white-space: nowrap;
            transition: all 0.15s;
            max-width: 180px;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px;
        }

        .document-tab:hover {
            background: #475569;
            color: #e2e8f0;
        }

        .document-tab.active {
            background: #f0f2f5;
            color: #1e293b;
            border-color: #334155;
        }

        .document-tab .tab-title {
            overflow: hidden;
            text-overflow: ellipsis;
            flex: 1;
        }

        .document-tab .tab-dirty {
            color: #fbbf24;
            font-weight: bold;
        }

        .document-tab.active .tab-dirty {
            color: #d97706;
        }

        .document-tab .tab-close {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 18px;
            height: 18px;
            border-radius: 3px;
            font-size: 14px;
            opacity: 0.6;
            transition: all 0.15s;
        }

        .document-tab .tab-close:hover {
            background: rgba(0,0,0,0.2);
            opacity: 1;
        }

        .document-tab.active .tab-close:hover {
            background: #e2e8f0;
        }

        .document-tabs-actions {
            display: flex;
            align-items: center;
            gap: 4px;
            padding-left: 8px;
            border-left: 1px solid #334155;
            margin-left: 4px;
        }

        .doc-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 28px;
            height: 28px;
            border: none;
            background: transparent;
            color: #94a3b8;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.15s;
        }

        .doc-action-btn:hover {
            background: #475569;
            color: #e2e8f0;
        }

        /* Unsaved Changes Modal */
        .modal.unsaved-modal {
            width: 400px;
        }

        .unsaved-modal .modal-body {
            text-align: center;
            padding: 24px 20px;
        }

        .unsaved-modal .unsaved-icon {
            font-size: 48px;
            margin-bottom: 16px;
        }

        .unsaved-modal .unsaved-message {
            font-size: 15px;
            color: #475569;
            margin-bottom: 8px;
        }

        .unsaved-modal .unsaved-filename {
            font-weight: 600;
            color: #1e293b;
            font-size: 16px;
        }

        .unsaved-modal .modal-footer {
            justify-content: center;
            gap: 12px;
        }

        .unsaved-modal .modal-footer .toolbar-btn {
            min-width: 100px;
        }

        /* Row Text Editor Modal Styles */
        .row-text-row {
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }
        .row-text-row-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-weight: 600;
            color: #475569;
        }
        .row-text-part {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 8px;
            padding: 8px;
            background: white;
            border-radius: 4px;
            border: 1px solid #e2e8f0;
        }
        .row-text-part input[type="text"] {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            font-size: 13px;
        }
        .row-text-part input.icon-input {
            width: 50px;
            flex: none;
            text-align: center;
        }
        .row-text-part label {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 12px;
            color: #64748b;
            white-space: nowrap;
        }
        .row-text-part .remove-part {
            background: none;
            border: none;
            color: #ef4444;
            cursor: pointer;
            padding: 4px;
            font-size: 14px;
        }
        .row-text-part .remove-part:hover {
            color: #dc2626;
        }

        /* Cell Text Editor Styles */
        .cell-editor-table {
            width: 100%;
            border-collapse: collapse;
        }
        .cell-editor-table th {
            background: var(--table-header-bg, #e0f2fe);
            padding: 8px;
            font-size: 12px;
            font-weight: 600;
            border: 1px solid #e2e8f0;
        }
        .cell-editor-table td {
            padding: 8px;
            border: 1px solid #e2e8f0;
            vertical-align: top;
        }
        .cell-editor-row-num {
            background: #f1f5f9;
            font-weight: 600;
            text-align: center;
            width: 40px;
            color: #64748b;
        }
        .cell-input-group {
            display: flex;
            gap: 6px;
            align-items: center;
        }
        .cell-input-group label {
            display: flex;
            align-items: center;
            font-size: 11px;
            color: #64748b;
            cursor: pointer;
        }
        .cell-text-input {
            flex: 1;
            padding: 6px 8px;
            border: 1px solid #cbd5e1;
            border-radius: 4px;
            font-size: 12px;
            min-width: 80px;
        }
        .cell-text-input:focus {
            outline: none;
            border-color: #3b82f6;
        }
    </style>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar - Component Palette -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h2>Components</h2>
            </div>

            <div class="component-group">
                <h3>Basic</h3>
                <div class="component-item" draggable="true" data-type="label">
                    <span class="icon">Aa</span>
                    <span>Label</span>
                </div>
                <div class="component-item" draggable="true" data-type="title">
                    <span class="icon">H</span>
                    <span>Title</span>
                </div>
                <div class="component-item" draggable="true" data-type="textbox">
                    <span class="icon">[ ]</span>
                    <span>TextBox</span>
                </div>
                <div class="component-item" draggable="true" data-type="textarea">
                    <span class="icon">[=]</span>
                    <span>TextArea</span>
                </div>
            </div>

            <div class="component-group">
                <h3>Input</h3>
                <div class="component-item" draggable="true" data-type="datepicker">
                    <span class="icon">üìÖ</span>
                    <span>DatePicker</span>
                </div>
                <div class="component-item" draggable="true" data-type="dropdown">
                    <span class="icon">‚ñº</span>
                    <span>Dropdown</span>
                </div>
                <div class="component-item" draggable="true" data-type="checkbox">
                    <span class="icon">‚òë</span>
                    <span>Checkbox</span>
                </div>
                <div class="component-item" draggable="true" data-type="radio">
                    <span class="icon">‚óâ</span>
                    <span>Radio</span>
                </div>
            </div>

            <div class="component-group">
                <h3>Actions</h3>
                <div class="component-item" draggable="true" data-type="button">
                    <span class="icon">‚ñ¢</span>
                    <span>Button</span>
                </div>
                <div class="component-item" draggable="true" data-type="iconbutton">
                    <span class="icon">‚óØ</span>
                    <span>Icon Button</span>
                </div>
            </div>

            <div class="component-group">
                <h3>Layout</h3>
                <div class="component-item" draggable="true" data-type="table">
                    <span class="icon">‚ñ¶</span>
                    <span>Table</span>
                </div>
                <div class="component-item" draggable="true" data-type="tabs">
                    <span class="icon">‚äû</span>
                    <span>Tabs</span>
                </div>
                <div class="component-item" draggable="true" data-type="panel">
                    <span class="icon">‚ñ≠</span>
                    <span>Panel</span>
                </div>
            </div>

            <div class="component-group">
                <h3>Annotation</h3>
                <div class="component-item" draggable="true" data-type="annotation">
                    <span class="icon">‚Üí</span>
                    <span>Arrow Note</span>
                </div>
                <div class="component-item" draggable="true" data-type="notebox">
                    <span class="icon">üìù</span>
                    <span>Note Box</span>
                </div>
            </div>

            <div class="component-group">
                <h3>Media</h3>
                <div class="component-item" draggable="true" data-type="image">
                    <span class="icon">üñºÔ∏è</span>
                    <span>Image</span>
                </div>
            </div>
        </div>

        <!-- Main Area -->
        <div class="main-area">
            <!-- Document Tabs Bar -->
            <div class="document-tabs-bar">
                <div class="document-tabs-container" id="documentTabs">
                    <!-- Tabs will be rendered here -->
                </div>
                <div class="document-tabs-actions">
                    <button class="doc-action-btn" onclick="newDocument()" title="New Document (Ctrl+N)">+</button>
                </div>
            </div>

            <!-- Toolbar -->
            <div class="toolbar">
                <div class="toolbar-group">
                    <button class="toolbar-btn" id="toggleRulersBtn" onclick="toggleRulersFromToolbar()" title="Show Rulers">üìè</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="docSave()" title="Save (Ctrl+S)">üíæ</button>
                    <button class="toolbar-btn" onclick="docSaveAs()" title="Save As">üìÑ</button>
                    <button class="toolbar-btn" onclick="docOpen()" title="Open (Ctrl+O)">üìÇ</button>
                    <button class="toolbar-btn" onclick="exportImage()" title="Export PNG">üñºÔ∏è</button>
                    <button class="toolbar-btn primary" onclick="showImportImageModal()" title="Import from Image">ü§ñ</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn" onclick="undo()" title="Undo (Ctrl+Z)">‚Ü©Ô∏è</button>
                    <button class="toolbar-btn" onclick="redo()" title="Redo (Ctrl+Y)">‚Ü™Ô∏è</button>
                </div>
                <div class="toolbar-group">
                    <button class="toolbar-btn danger" onclick="clearCanvas()" title="Clear All">üóëÔ∏è</button>
                </div>
            </div>

            <!-- Canvas -->
            <div class="canvas-container">
                <div class="canvas" id="canvas">
                    <!-- Grid Overlay -->
                    <div class="grid-overlay grid-small" id="gridOverlay"></div>
                    <!-- Rulers -->
                    <div class="ruler-corner" id="rulerCorner"></div>
                    <div class="ruler ruler-horizontal" id="rulerHorizontal"></div>
                    <div class="ruler ruler-vertical" id="rulerVertical"></div>
                    <!-- Dropped components will appear here -->
                    <!-- Marquee Selection -->
                    <div class="marquee-selection" id="marqueeSelection"></div>
                    <!-- Canvas Resize Handles -->
                    <div class="canvas-resize-handle right" data-resize="e"></div>
                    <div class="canvas-resize-handle bottom" data-resize="s"></div>
                    <div class="canvas-resize-handle corner" data-resize="se"></div>
                </div>
            </div>
        </div>

        <!-- Properties Panel -->
        <div class="properties-panel" id="propertiesPanel">
            <div class="properties-header">Properties</div>
            <div class="properties-content" id="propertiesContent">
                <p style="color: #94a3b8; font-size: 13px;">Select a component to edit its properties</p>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu hidden" id="contextMenu">
        <div class="context-menu-item" onclick="duplicateSelectedComponents()">
            üìã Duplicate (Ctrl+D)
        </div>
        <div class="context-menu-item" onclick="bringToFront()">
            ‚¨ÜÔ∏è Bring to Front
        </div>
        <div class="context-menu-item" onclick="sendToBack()">
            ‚¨áÔ∏è Send to Back
        </div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item danger" onclick="deleteSelectedComponents()">
            üóëÔ∏è Delete (Del)
        </div>
    </div>

    <!-- Hidden canvas/screen settings (used by JavaScript) -->
    <input type="hidden" id="canvasWidthHidden" value="1200">
    <input type="hidden" id="canvasHeightHidden" value="800">
    <input type="hidden" id="screenNameHidden" value="sc-new">
    <input type="hidden" id="screenTitleHidden" value="‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÉ‡∏´‡∏°‡πà">

    <!-- Hidden file input for loading JSON -->
    <input type="file" id="fileInput" accept=".json" style="display: none;">

    <!-- Hidden file input for AI image import -->
    <input type="file" id="imageInput" accept="image/*" style="display: none;">

    <!-- Hidden file input for component image -->
    <input type="file" id="componentImageInput" accept="image/*" style="display: none;">

    <!-- Import from Image Modal -->
    <div class="modal-overlay hidden" id="importImageModal">
        <div class="modal" style="width: 600px;">
            <div class="modal-header">
                <span>ü§ñ Import UI from Image</span>
                <button class="modal-close" onclick="closeImportImageModal()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="property-group">
                    <label>Anthropic API Key</label>
                    <input type="password" id="apiKeyInput" placeholder="sk-ant-api03-..." style="width: 100%;">
                    <small style="color: #64748b;">API Key ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡πÄ‡∏Å‡πá‡∏ö‡πÉ‡∏ô browser (localStorage)</small>
                </div>
                <div class="property-group" style="margin-top: 16px;">
                    <label>Select Image</label>
                    <div id="imageDropZone" style="border: 2px dashed #cbd5e1; border-radius: 8px; padding: 40px; text-align: center; cursor: pointer; background: #f8fafc;">
                        <div id="imagePreviewContainer" style="display: none;">
                            <img id="imagePreview" style="max-width: 100%; max-height: 300px; border-radius: 4px;">
                            <p style="margin-top: 8px; color: #64748b; font-size: 13px;">Click to change image</p>
                        </div>
                        <div id="imagePlaceholder">
                            <span style="font-size: 48px;">üì∑</span>
                            <p style="color: #64748b; margin-top: 8px;">Click or drag image here</p>
                        </div>
                    </div>
                </div>
                <div id="importStatus" style="margin-top: 16px; display: none;">
                    <div style="display: flex; align-items: center; gap: 8px; color: #3b82f6;">
                        <span class="spinner"></span>
                        <span>Analyzing image with Claude AI...</span>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="toolbar-btn" onclick="closeImportImageModal()">Cancel</button>
                <button class="toolbar-btn primary" onclick="analyzeImage()" id="analyzeBtn" disabled>ü§ñ Analyze & Import</button>
            </div>
        </div>
    </div>

    <!-- Unsaved Changes Modal -->
    <div class="modal-overlay hidden" id="unsavedChangesModal">
        <div class="modal unsaved-modal">
            <div class="modal-header">
                <span>Save Changes?</span>
                <button class="modal-close" onclick="closeUnsavedModal('cancel')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="unsaved-icon">üìÑ</div>
                <div class="unsaved-message">Do you want to save changes to</div>
                <div class="unsaved-filename" id="unsavedFileName">Untitled</div>
            </div>
            <div class="modal-footer">
                <button class="toolbar-btn" onclick="closeUnsavedModal('dontsave')">Don't Save</button>
                <button class="toolbar-btn" onclick="closeUnsavedModal('cancel')">Cancel</button>
                <button class="toolbar-btn primary" onclick="closeUnsavedModal('save')">Save</button>
            </div>
        </div>
    </div>

    <!-- Cell Text Editor Modal -->
    <div class="modal-overlay hidden" id="cellTextEditorModal">
        <div class="modal" style="width: 750px; max-height: 85vh;">
            <div class="modal-header">
                <span>üìù Edit Cell Texts</span>
                <button class="modal-close" onclick="closeCellTextEditor()">&times;</button>
            </div>
            <div class="modal-body" style="max-height: 65vh; overflow-y: auto;">
                <div id="cellTextEditorContent"></div>
            </div>
            <div class="modal-footer">
                <button class="toolbar-btn" onclick="closeCellTextEditor()" style="min-width: 80px;">Cancel</button>
                <button class="toolbar-btn primary" onclick="applyCellTexts()" style="min-width: 80px;">Apply</button>
            </div>
        </div>
    </div>

    <style>
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid #e2e8f0;
            border-top-color: #3b82f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>

    <script>
        // State
        let components = [];
        let selectedComponent = null;
        let selectedComponents = []; // For multi-selection
        let draggedType = null;
        let isDragging = false;
        let isMultiDragging = false;
        let dragOffset = { x: 0, y: 0 };
        let multiDragOffsets = []; // Store offsets for each selected component
        let history = [];
        let historyIndex = -1;
        let componentIdCounter = 1;
        let isResizing = false;
        let resizeHandle = null;
        let resizeStart = { x: 0, y: 0, width: 0, height: 0 };
        let currentTheme = 'default';
        let preventNextDrag = false; // Prevent drag after double-click
        let dragTimeout = null; // Timeout for delayed drag start

        // Marquee selection
        let isMarqueeSelecting = false;
        let marqueeJustFinished = false;
        let marqueeStart = { x: 0, y: 0 };
        let marqueeEl = null;

        // Grid and guides settings
        let gridSettings = {
            showGrid: false,
            showRulers: true,
            snapToGrid: false,
            gridSize: 'small', // 'small' (10px), 'medium' (50px), 'large' (100px)
            snapSize: 10 // pixels for snap-to-grid
        };

        // Grid size mappings
        const gridSizes = {
            small: 10,
            medium: 50,
            large: 100
        };

        // ============================================
        // Document Management System
        // ============================================

        // Document model
        class Document {
            constructor(id = null) {
                this.id = id || this.generateId();
                this.filePath = null; // null = never saved
                this.fileHandle = null; // File System Access API handle
                this.displayName = 'Untitled';
                this.isDirty = false;
                this.content = {
                    screenId: 'sc-new',
                    screenTitle: '‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÉ‡∏´‡∏°‡πà',
                    theme: 'default',
                    canvasWidth: 1200,
                    canvasHeight: 800,
                    components: [],
                    version: '1.0'
                };
                this.history = [];
                this.historyIndex = -1;
                this.componentIdCounter = 1;
            }

            generateId() {
                return 'doc_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
            }

            getTabTitle() {
                return this.displayName + (this.isDirty ? '*' : '');
            }
        }

        // Document state
        let documents = [];
        let activeDocumentId = null;
        let untitledCounter = 1;
        let pendingUnsavedAction = null; // { action: 'close'|'switch', docId, targetDocId }

        // Get active document
        function getActiveDocument() {
            return documents.find(d => d.id === activeDocumentId);
        }

        // Generate unique untitled name
        function generateUntitledName() {
            const name = untitledCounter === 1 ? 'Untitled' : `Untitled ${untitledCounter}`;
            untitledCounter++;
            return name;
        }

        // Calculate default canvas size based on visible area
        function getDefaultCanvasSize() {
            const container = document.querySelector('.canvas-container');
            if (!container) return { width: 1200, height: 800 };

            const containerRect = container.getBoundingClientRect();
            // Account for ruler space (30px) and some padding (40px)
            const rulerSpace = 30;
            const padding = 40;

            let width = Math.floor(containerRect.width - rulerSpace - padding);
            let height = Math.floor(containerRect.height - rulerSpace - padding);

            // Round to nearest 50 for cleaner values
            width = Math.floor(width / 50) * 50;
            height = Math.floor(height / 50) * 50;

            // Ensure minimum size
            width = Math.max(400, Math.min(width, 1200));
            height = Math.max(300, Math.min(height, 800));

            return { width, height };
        }

        // Create new document
        function newDocument() {
            const doc = new Document();
            doc.displayName = generateUntitledName();
            doc.content.screenId = 'sc-new';
            doc.content.screenTitle = doc.displayName;

            // Set canvas size to fit visible area
            const defaultSize = getDefaultCanvasSize();
            doc.content.canvasWidth = defaultSize.width;
            doc.content.canvasHeight = defaultSize.height;

            documents.push(doc);
            switchToDocument(doc.id);
            renderDocumentTabs();
            showToast('New document created', 'success');
        }

        // Switch to a document
        function switchToDocument(docId) {
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            // Save current document state if exists
            const currentDoc = getActiveDocument();
            if (currentDoc) {
                saveDocumentState(currentDoc);
            }

            // Switch active document
            activeDocumentId = docId;

            // Load document state
            loadDocumentState(doc);
            renderDocumentTabs();
        }

        // Save current canvas state to document
        function saveDocumentState(doc) {
            doc.content.screenId = getScreenName();
            doc.content.screenTitle = getScreenTitle();
            doc.content.theme = currentTheme;
            doc.content.canvasWidth = getCanvasWidth();
            doc.content.canvasHeight = getCanvasHeight();
            doc.content.components = JSON.parse(JSON.stringify(components));
            doc.history = JSON.parse(JSON.stringify(history));
            doc.historyIndex = historyIndex;
            doc.componentIdCounter = componentIdCounter;
        }

        // Load document state to canvas
        function loadDocumentState(doc) {
            setScreenNameValue(doc.content.screenId || 'sc-new');
            setScreenTitleValue(doc.content.screenTitle || '‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÉ‡∏´‡∏°‡πà');

            // Load theme
            currentTheme = doc.content.theme || 'default';
            const themeSelect = document.getElementById('themeSelect');
            if (themeSelect) themeSelect.value = currentTheme;
            if (currentTheme === 'default') {
                document.documentElement.removeAttribute('data-theme');
                document.getElementById('canvas').removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', currentTheme);
                document.getElementById('canvas').setAttribute('data-theme', currentTheme);
            }

            // Load canvas size
            setCanvasWidthValue(doc.content.canvasWidth || 1200);
            setCanvasHeightValue(doc.content.canvasHeight || 800);

            // Load components
            components = JSON.parse(JSON.stringify(doc.content.components || []));
            history = JSON.parse(JSON.stringify(doc.history || []));
            historyIndex = doc.historyIndex;
            componentIdCounter = doc.componentIdCounter || 1;

            // Re-render canvas
            rerenderCanvas();
            setCanvasSize(false);

            // Show canvas properties if no component selected
            showCanvasProperties();

            // Initialize history for new documents
            if (history.length === 0) {
                historyIndex = -1;
                saveHistory(true); // Skip marking as dirty
            }
        }

        // Mark document as dirty
        function markDocumentDirty() {
            const doc = getActiveDocument();
            if (doc && !doc.isDirty) {
                doc.isDirty = true;
                renderDocumentTabs();
            }
        }

        // Mark document as clean
        function markDocumentClean() {
            const doc = getActiveDocument();
            if (doc) {
                doc.isDirty = false;
                renderDocumentTabs();
            }
        }

        // Render document tabs
        function renderDocumentTabs() {
            const container = document.getElementById('documentTabs');
            container.innerHTML = '';

            documents.forEach(doc => {
                const tab = document.createElement('div');
                tab.className = 'document-tab' + (doc.id === activeDocumentId ? ' active' : '');
                tab.onclick = (e) => {
                    if (!e.target.classList.contains('tab-close')) {
                        handleTabClick(doc.id);
                    }
                };

                const titleSpan = document.createElement('span');
                titleSpan.className = 'tab-title';
                titleSpan.textContent = doc.displayName;

                const dirtySpan = document.createElement('span');
                dirtySpan.className = 'tab-dirty';
                dirtySpan.textContent = doc.isDirty ? '*' : '';

                const closeBtn = document.createElement('span');
                closeBtn.className = 'tab-close';
                closeBtn.textContent = '√ó';
                closeBtn.onclick = (e) => {
                    e.stopPropagation();
                    closeDocument(doc.id);
                };

                tab.appendChild(titleSpan);
                tab.appendChild(dirtySpan);
                tab.appendChild(closeBtn);
                container.appendChild(tab);
            });

            // Update page title
            const activeDoc = getActiveDocument();
            if (activeDoc) {
                document.title = activeDoc.getTabTitle() + ' - SA Screen Designer';
            }
        }

        // Handle tab click
        function handleTabClick(docId) {
            if (docId === activeDocumentId) return;

            const currentDoc = getActiveDocument();
            if (currentDoc && currentDoc.isDirty) {
                pendingUnsavedAction = { action: 'switch', docId: currentDoc.id, targetDocId: docId };
                showUnsavedModal(currentDoc.displayName);
            } else {
                switchToDocument(docId);
            }
        }

        // Close document
        function closeDocument(docId) {
            const doc = documents.find(d => d.id === docId);
            if (!doc) return;

            if (doc.isDirty) {
                pendingUnsavedAction = { action: 'close', docId: docId };
                showUnsavedModal(doc.displayName);
            } else {
                performCloseDocument(docId);
            }
        }

        // Actually close the document
        function performCloseDocument(docId) {
            const index = documents.findIndex(d => d.id === docId);
            if (index === -1) return;

            documents.splice(index, 1);

            // If no documents left, create new one
            if (documents.length === 0) {
                newDocument();
                return;
            }

            // If closed active document, switch to another
            if (docId === activeDocumentId) {
                const newIndex = Math.min(index, documents.length - 1);
                switchToDocument(documents[newIndex].id);
            } else {
                renderDocumentTabs();
            }
        }

        // Show unsaved changes modal
        function showUnsavedModal(fileName) {
            document.getElementById('unsavedFileName').textContent = fileName;
            document.getElementById('unsavedChangesModal').classList.remove('hidden');
        }

        // Close unsaved modal
        async function closeUnsavedModal(action) {
            document.getElementById('unsavedChangesModal').classList.add('hidden');

            if (!pendingUnsavedAction) return;

            const { action: pendingAction, docId, targetDocId } = pendingUnsavedAction;
            pendingUnsavedAction = null;

            if (action === 'cancel') {
                return;
            }

            if (action === 'save') {
                // Save first, then continue
                const doc = documents.find(d => d.id === docId);
                if (doc) {
                    if (doc.fileHandle) {
                        // Has file handle, save directly to same file
                        await saveDocumentToFileHandle(doc, () => {
                            continuePendingAction(pendingAction, docId, targetDocId);
                        });
                    } else {
                        // No file handle, show save dialog
                        await docSaveAsForDocument(doc, () => {
                            continuePendingAction(pendingAction, docId, targetDocId);
                        });
                    }
                }
            } else if (action === 'dontsave') {
                // Don't save, just continue
                const doc = documents.find(d => d.id === docId);
                if (doc) {
                    doc.isDirty = false;
                }
                continuePendingAction(pendingAction, docId, targetDocId);
            }
        }

        // Continue pending action after save decision
        function continuePendingAction(action, docId, targetDocId) {
            if (action === 'close') {
                performCloseDocument(docId);
            } else if (action === 'switch') {
                switchToDocument(targetDocId);
            }
        }

        // Check if File System Access API is supported
        function isFileSystemAccessSupported() {
            return 'showSaveFilePicker' in window && 'showOpenFilePicker' in window;
        }

        // Save - if has fileHandle, save directly; otherwise do Save As
        async function docSave() {
            const doc = getActiveDocument();
            if (!doc) return;

            // Save current state first
            saveDocumentState(doc);

            if (doc.fileHandle) {
                // Has file handle, save directly to the same file
                await saveDocumentToFileHandle(doc);
            } else {
                // No file handle, do Save As
                await docSaveAs();
            }
        }

        // Save As - always ask for name/location
        async function docSaveAs() {
            const doc = getActiveDocument();
            if (!doc) return;

            saveDocumentState(doc);
            await docSaveAsForDocument(doc);
        }

        // Save As for specific document
        async function docSaveAsForDocument(doc, callback) {
            const design = {
                screenId: doc.content.screenId,
                screenTitle: doc.content.screenTitle,
                theme: doc.content.theme,
                canvasWidth: doc.content.canvasWidth,
                canvasHeight: doc.content.canvasHeight,
                components: doc.content.components,
                version: '1.0',
                createdAt: new Date().toISOString()
            };

            const json = JSON.stringify(design, null, 2);
            const blob = new Blob([json], { type: 'application/json' });

            // Try File System Access API first
            if (isFileSystemAccessSupported()) {
                try {
                    const suggestedName = (doc.content.screenId || 'screen') + '.json';
                    const handle = await window.showSaveFilePicker({
                        suggestedName: suggestedName,
                        types: [{
                            description: 'JSON Design File',
                            accept: { 'application/json': ['.json'] }
                        }]
                    });

                    const writable = await handle.createWritable();
                    await writable.write(blob);
                    await writable.close();

                    // Store the file handle for future saves
                    doc.fileHandle = handle;
                    doc.filePath = handle.name;
                    doc.displayName = handle.name.replace('.json', '');
                    doc.isDirty = false;
                    renderDocumentTabs();

                    showToast('Design saved: ' + handle.name, 'success');

                    if (callback) callback();
                    return;
                } catch (err) {
                    // User cancelled or error - fall through to legacy method
                    if (err.name !== 'AbortError') {
                        console.error('File System Access API error:', err);
                    } else {
                        // User cancelled
                        return;
                    }
                }
            }

            // Fallback: Legacy download method
            const url = URL.createObjectURL(blob);
            const fileName = (doc.content.screenId || 'screen') + '.json';

            const a = document.createElement('a');
            a.href = url;
            a.download = fileName;
            a.click();

            URL.revokeObjectURL(url);

            // Update document info
            doc.filePath = fileName;
            doc.displayName = fileName.replace('.json', '');
            doc.isDirty = false;
            renderDocumentTabs();

            showToast('Design saved: ' + fileName, 'success');

            if (callback) callback();
        }

        // Save document directly to existing file handle
        async function saveDocumentToFileHandle(doc, callback) {
            const design = {
                screenId: doc.content.screenId,
                screenTitle: doc.content.screenTitle,
                theme: doc.content.theme,
                canvasWidth: doc.content.canvasWidth,
                canvasHeight: doc.content.canvasHeight,
                components: doc.content.components,
                version: '1.0',
                createdAt: new Date().toISOString()
            };

            const json = JSON.stringify(design, null, 2);
            const blob = new Blob([json], { type: 'application/json' });

            try {
                const writable = await doc.fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();

                doc.isDirty = false;
                renderDocumentTabs();

                showToast('Design saved!', 'success');

                if (callback) callback();
            } catch (err) {
                console.error('Error saving file:', err);
                showToast('Error saving file. Try Save As.', 'error');
                // Clear the file handle since it's no longer valid
                doc.fileHandle = null;
            }
        }

        // Legacy save function (download) - kept for compatibility
        function saveDocumentToFile(doc, callback) {
            const design = {
                screenId: doc.content.screenId,
                screenTitle: doc.content.screenTitle,
                theme: doc.content.theme,
                canvasWidth: doc.content.canvasWidth,
                canvasHeight: doc.content.canvasHeight,
                components: doc.content.components,
                version: '1.0',
                createdAt: new Date().toISOString()
            };

            const json = JSON.stringify(design, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = doc.filePath || (doc.content.screenId || 'screen') + '.json';
            a.click();

            URL.revokeObjectURL(url);

            doc.isDirty = false;
            renderDocumentTabs();

            showToast('Design saved!', 'success');

            if (callback) callback();
        }

        // Open document
        // Open document using File System Access API or fallback
        async function docOpen() {
            if (isFileSystemAccessSupported()) {
                try {
                    const [handle] = await window.showOpenFilePicker({
                        types: [{
                            description: 'JSON Design File',
                            accept: { 'application/json': ['.json'] }
                        }],
                        multiple: false
                    });

                    const file = await handle.getFile();
                    const text = await file.text();
                    const design = JSON.parse(text);

                    // Create new document with file handle
                    const doc = new Document();
                    doc.fileHandle = handle; // Store handle for direct save
                    doc.filePath = handle.name;
                    doc.displayName = handle.name.replace('.json', '');
                    doc.content.screenId = design.screenId || '';
                    doc.content.screenTitle = design.screenTitle || '';
                    doc.content.theme = design.theme || 'default';
                    doc.content.canvasWidth = design.canvasWidth || 1200;
                    doc.content.canvasHeight = design.canvasHeight || 800;
                    doc.content.components = design.components || [];
                    doc.isDirty = false;

                    // Find max component ID
                    doc.componentIdCounter = 1;
                    doc.content.components.forEach(c => {
                        const num = parseInt(c.id.replace('comp_', ''));
                        if (num >= doc.componentIdCounter) doc.componentIdCounter = num + 1;
                    });

                    documents.push(doc);
                    switchToDocument(doc.id);
                    renderDocumentTabs();

                    showToast('Document opened: ' + handle.name, 'success');
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        console.error('Error opening file:', err);
                        showToast('Error opening file: ' + err.message, 'error');
                    }
                }
            } else {
                // Fallback to file input
                document.getElementById('fileInput').click();
            }
        }

        // Handle file input change for opening (legacy fallback)
        function handleFileOpen(file) {
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const design = JSON.parse(e.target.result);

                    // Create new document (no fileHandle in legacy mode)
                    const doc = new Document();
                    doc.filePath = file.name;
                    doc.displayName = file.name.replace('.json', '');
                    doc.content.screenId = design.screenId || '';
                    doc.content.screenTitle = design.screenTitle || '';
                    doc.content.theme = design.theme || 'default';
                    doc.content.canvasWidth = design.canvasWidth || 1200;
                    doc.content.canvasHeight = design.canvasHeight || 800;
                    doc.content.components = design.components || [];
                    doc.isDirty = false;

                    // Find max component ID
                    doc.componentIdCounter = 1;
                    doc.content.components.forEach(c => {
                        const num = parseInt(c.id.replace('comp_', ''));
                        if (num >= doc.componentIdCounter) doc.componentIdCounter = num + 1;
                    });

                    documents.push(doc);
                    switchToDocument(doc.id);
                    renderDocumentTabs();

                    showToast('Document opened: ' + file.name, 'success');
                } catch (err) {
                    showToast('Error loading file: ' + err.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // Initialize with first document
        function initDocumentSystem() {
            newDocument();
        }

        // Theme management
        function changeTheme(theme, skipDirty = false) {
            currentTheme = theme;
            if (theme === 'default') {
                document.documentElement.removeAttribute('data-theme');
            } else {
                document.documentElement.setAttribute('data-theme', theme);
            }
            // Also apply to canvas for export
            const canvas = document.getElementById('canvas');
            if (theme === 'default') {
                canvas.removeAttribute('data-theme');
            } else {
                canvas.setAttribute('data-theme', theme);
            }
            showToast(`Theme changed to: ${getThemeName(theme)}`, 'success');

            // Mark document as dirty
            if (!skipDirty) {
                markDocumentDirty();
            }
        }

        function getThemeName(theme) {
            const names = {
                'default': 'Default',
                'aj': 'AJ Style (Teal)',
                'metronic': 'Metronic (KeenThemes)',
                'blue': 'Blue',
                'purple': 'Purple',
                'gray': 'Gray'
            };
            return names[theme] || theme;
        }

        // Grid and Guides Functions
        function toggleGrid() {
            const checkbox = document.getElementById('showGridCheck');
            if (checkbox) gridSettings.showGrid = checkbox.checked;
            const gridOverlay = document.getElementById('gridOverlay');
            if (gridSettings.showGrid) {
                gridOverlay.classList.add('visible');
            } else {
                gridOverlay.classList.remove('visible');
            }
        }

        function toggleRulers() {
            const checkbox = document.getElementById('showRulersCheck');
            if (checkbox) gridSettings.showRulers = checkbox.checked;
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            const rulerCorner = document.getElementById('rulerCorner');
            const canvas = document.getElementById('canvas');

            if (gridSettings.showRulers) {
                rulerH.classList.add('visible');
                rulerV.classList.add('visible');
                rulerCorner.classList.add('visible');
                canvas.classList.add('with-rulers');
                drawRulers();
            } else {
                rulerH.classList.remove('visible');
                rulerV.classList.remove('visible');
                rulerCorner.classList.remove('visible');
                canvas.classList.remove('with-rulers');
            }
            updateRulerButtonState();
        }

        function toggleRulersFromToolbar() {
            gridSettings.showRulers = !gridSettings.showRulers;
            const checkbox = document.getElementById('showRulersCheck');
            if (checkbox) checkbox.checked = gridSettings.showRulers;
            toggleRulers();
        }

        function updateRulerButtonState() {
            const btn = document.getElementById('toggleRulersBtn');
            if (btn) {
                if (gridSettings.showRulers) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }

        function toggleSnapToGrid() {
            const checkbox = document.getElementById('snapToGridCheck');
            if (checkbox) gridSettings.snapToGrid = checkbox.checked;
            if (gridSettings.snapToGrid) {
                showToast('Snap to Grid enabled', 'success');
            }
        }

        function setGridSize(size) {
            gridSettings.gridSize = size;
            gridSettings.snapSize = gridSizes[size];

            const gridOverlay = document.getElementById('gridOverlay');
            gridOverlay.classList.remove('grid-small', 'grid-medium', 'grid-large');
            gridOverlay.classList.add(`grid-${size}`);

            // Redraw rulers if visible
            if (gridSettings.showRulers) {
                drawRulers();
            }
        }

        function drawRulers() {
            const rulerH = document.getElementById('rulerHorizontal');
            const rulerV = document.getElementById('rulerVertical');
            const canvas = document.getElementById('canvas');
            const canvasWidth = canvas.offsetWidth;
            const canvasHeight = canvas.offsetHeight;
            const step = gridSizes[gridSettings.gridSize];

            // Clear existing ruler marks
            rulerH.innerHTML = '';
            rulerV.innerHTML = '';

            // Draw horizontal ruler marks
            for (let x = 0; x <= canvasWidth; x += step) {
                const mark = document.createElement('div');
                mark.style.cssText = `
                    position: absolute;
                    left: ${x}px;
                    bottom: 0;
                    width: 1px;
                    height: ${x % (step * 5) === 0 ? '12px' : '6px'};
                    background: #94a3b8;
                `;
                rulerH.appendChild(mark);

                // Add number labels at major marks
                if (x % (step * 5) === 0 && x > 0) {
                    const label = document.createElement('span');
                    label.style.cssText = `
                        position: absolute;
                        left: ${x}px;
                        top: 2px;
                        font-size: 9px;
                        color: #64748b;
                        transform: translateX(-50%);
                    `;
                    label.textContent = x;
                    rulerH.appendChild(label);
                }
            }

            // Draw vertical ruler marks
            for (let y = 0; y <= canvasHeight; y += step) {
                const mark = document.createElement('div');
                mark.style.cssText = `
                    position: absolute;
                    top: ${y}px;
                    right: 0;
                    height: 1px;
                    width: ${y % (step * 5) === 0 ? '12px' : '6px'};
                    background: #94a3b8;
                `;
                rulerV.appendChild(mark);

                // Add number labels at major marks
                if (y % (step * 5) === 0 && y > 0) {
                    const label = document.createElement('span');
                    label.style.cssText = `
                        position: absolute;
                        top: ${y}px;
                        left: 2px;
                        font-size: 9px;
                        color: #64748b;
                        transform: translateY(-50%);
                        writing-mode: vertical-rl;
                        text-orientation: mixed;
                    `;
                    label.textContent = y;
                    rulerV.appendChild(label);
                }
            }
        }

        // Snap position to grid
        function snapToGrid(value) {
            if (!gridSettings.snapToGrid) return value;
            const snapSize = gridSettings.snapSize;
            return Math.round(value / snapSize) * snapSize;
        }

        // Canvas setup
        const canvas = document.getElementById('canvas');
        const propertiesContent = document.getElementById('propertiesContent');
        const contextMenu = document.getElementById('contextMenu');
        const fileInput = document.getElementById('fileInput');

        // Drag from palette
        document.querySelectorAll('.component-item').forEach(item => {
            item.addEventListener('dragstart', (e) => {
                draggedType = item.dataset.type;
                e.dataTransfer.effectAllowed = 'copy';
                e.dataTransfer.setData('componentType', item.dataset.type);
            });

            item.addEventListener('dragend', () => {
                // Delay clearing to ensure drop event fires first
                setTimeout(() => {
                    draggedType = null;
                }, 50);
            });
        });

        // Canvas drop zone
        canvas.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            canvas.classList.add('drag-over');
        });

        canvas.addEventListener('dragleave', () => {
            canvas.classList.remove('drag-over');
        });

        canvas.addEventListener('drop', (e) => {
            e.preventDefault();
            canvas.classList.remove('drag-over');

            if (draggedType) {
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                addComponent(draggedType, x, y);
                draggedType = null; // Clear after drop to prevent accidental creation
            }
        });

        // Click on canvas to deselect
        // Marquee selection - mouse down on canvas
        canvas.addEventListener('mousedown', (e) => {
            // Skip if clicking on resize handles
            if (e.target.classList.contains('canvas-resize-handle')) return;
            if (e.target.classList.contains('resize-handle')) return;

            // Disable any active text editing
            disableAllTextEditing();

            // Only start marquee if clicking directly on canvas background
            // (not on dropped components or their children)
            const isOnCanvas = e.target === canvas ||
                               e.target.id === 'marqueeSelection' ||
                               e.target.closest('.canvas') === canvas && !e.target.closest('.dropped-component');

            if (isOnCanvas && !e.target.closest('.dropped-component')) {
                e.preventDefault();
                marqueeEl = document.getElementById('marqueeSelection');
                const rect = canvas.getBoundingClientRect();
                const container = canvas.parentElement; // canvas-container

                marqueeStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                isMarqueeSelecting = true;

                marqueeEl.style.left = marqueeStart.x + 'px';
                marqueeEl.style.top = marqueeStart.y + 'px';
                marqueeEl.style.width = '0px';
                marqueeEl.style.height = '0px';
                marqueeEl.style.display = 'block';

                // Clear selection unless holding Shift
                if (!e.shiftKey) {
                    clearSelection();
                }
            }
        });

        // Marquee selection - mouse move
        document.addEventListener('mousemove', (e) => {
            if (!isMarqueeSelecting || !marqueeEl) return;

            const rect = canvas.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const x = Math.min(marqueeStart.x, currentX);
            const y = Math.min(marqueeStart.y, currentY);
            const width = Math.abs(currentX - marqueeStart.x);
            const height = Math.abs(currentY - marqueeStart.y);

            marqueeEl.style.left = x + 'px';
            marqueeEl.style.top = y + 'px';
            marqueeEl.style.width = width + 'px';
            marqueeEl.style.height = height + 'px';
        });

        // Marquee selection - mouse up
        document.addEventListener('mouseup', (e) => {
            // Cancel pending drag timeout on mouseup
            if (dragTimeout) {
                clearTimeout(dragTimeout);
                dragTimeout = null;
                preventNextDrag = false;
            }

            if (isMarqueeSelecting && marqueeEl) {
                const marqueeWidth = parseInt(marqueeEl.style.width) || 0;
                const marqueeHeight = parseInt(marqueeEl.style.height) || 0;

                // Only process if marquee has some size (not just a click)
                if (marqueeWidth > 5 || marqueeHeight > 5) {
                    const marqueeRect = {
                        left: parseInt(marqueeEl.style.left),
                        top: parseInt(marqueeEl.style.top),
                        right: parseInt(marqueeEl.style.left) + marqueeWidth,
                        bottom: parseInt(marqueeEl.style.top) + marqueeHeight
                    };

                    // Find components that intersect with marquee
                    const selectedIds = [];
                    components.forEach(comp => {
                        const compRect = {
                            left: comp.x,
                            top: comp.y,
                            right: comp.x + comp.width,
                            bottom: comp.y + comp.height
                        };

                        // Check intersection
                        if (!(compRect.right < marqueeRect.left ||
                              compRect.left > marqueeRect.right ||
                              compRect.bottom < marqueeRect.top ||
                              compRect.top > marqueeRect.bottom)) {
                            selectedIds.push(comp.id);
                        }
                    });

                    if (selectedIds.length > 0) {
                        selectMultipleComponents(selectedIds);
                    }

                    marqueeJustFinished = true;
                    setTimeout(() => { marqueeJustFinished = false; }, 100);
                }

                marqueeEl.style.display = 'none';
                isMarqueeSelecting = false;
            }
        });

        canvas.addEventListener('click', (e) => {
            // Don't clear if marquee just finished or if clicking on component
            if (marqueeJustFinished) return;
            if (e.target.closest('.dropped-component')) return;
            // Disable any active text editing and clear selection
            disableAllTextEditing();
            clearSelection();
        });

        // Hide context menu on click and disable text editing if clicking outside canvas
        document.addEventListener('click', (e) => {
            contextMenu.classList.add('hidden');
            // If clicking outside canvas, disable text editing
            if (!e.target.closest('.canvas') && !e.target.closest('.properties-panel')) {
                disableAllTextEditing();
            }
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Delete selected components
            if (e.key === 'Delete' && selectedComponents.length > 0) {
                deleteSelectedComponents();
            }
            // Ctrl+D to duplicate selected
            if (e.ctrlKey && e.key === 'd') {
                e.preventDefault();
                if (selectedComponents.length > 0) {
                    duplicateSelectedComponents();
                }
            }
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
            }
            if (e.ctrlKey && e.key === 'y') {
                e.preventDefault();
                redo();
            }
        });

        // Add component to canvas
        function addComponent(type, x, y) {
            const id = `comp_${componentIdCounter++}`;
            const component = {
                id,
                type,
                x: snapToGrid(x),
                y: snapToGrid(y),
                width: getDefaultWidth(type),
                height: getDefaultHeight(type),
                properties: getDefaultProperties(type)
            };

            components.push(component);
            renderComponent(component);
            selectComponent(id);
            saveHistory();
            autoResizeCanvas();
        }

        function getDefaultWidth(type) {
            const widths = {
                label: 100,
                title: 200,
                textbox: 200,
                textarea: 300,
                datepicker: 200,
                dropdown: 200,
                checkbox: 150,
                radio: 150,
                button: 100,
                iconbutton: 36,
                table: 500,
                tabs: 400,
                panel: 300,
                annotation: 150,
                notebox: 200,
                image: 300
            };
            return widths[type] || 100;
        }

        function getDefaultHeight(type) {
            const heights = {
                label: 30,
                title: 40,
                textbox: 36,
                textarea: 80,
                datepicker: 36,
                dropdown: 36,
                checkbox: 30,
                radio: 30,
                button: 36,
                iconbutton: 36,
                table: 150,
                tabs: 200,
                panel: 150,
                annotation: 50,
                notebox: 60,
                image: 200
            };
            return heights[type] || 30;
        }

        function getDefaultProperties(type) {
            const props = {
                label: { text: 'Label Text', fontSize: 14, bold: false },
                title: { text: 'Page Title', fontSize: 18 },
                textbox: { placeholder: 'Enter text...', width: 200, required: false, fieldName: 'field_name' },
                textarea: { placeholder: 'Enter text...', rows: 3, fieldName: 'field_name' },
                datepicker: { placeholder: 'dd/mm/yyyy', fieldName: 'date_field' },
                dropdown: { placeholder: 'Select...', options: 'Option 1, Option 2, Option 3', fieldName: 'dropdown_field' },
                checkbox: { label: 'Checkbox label', checked: false, fieldName: 'checkbox_field' },
                radio: { label: 'Radio label', group: 'group1', fieldName: 'radio_field' },
                button: { text: 'Button', style: 'default', action: 'onClick' },
                iconbutton: { icon: 'edit', iconType: 'keenicons', tooltip: 'Edit', action: 'onEdit' },
                table: {
                    columns: 'Column 1, Column 2, Column 3',
                    rows: 3,
                    fieldName: 'table_data',
                    cellTexts: [],  // 2D array: cellTexts[row][col] = {parts: [{text, bold, underline, icon}]}
                    hasActionColumn: true,
                    actionColumnPosition: 'left',
                    actionIcons: 'edit, delete',
                    actionIconType: 'keenicons'
                },
                tabs: { tabs: 'Tab 1, Tab 2, Tab 3', activeTab: 0 },
                panel: { title: 'Panel Title' },
                annotation: { text: 'Annotation note', direction: 'right' },
                notebox: { text: 'Note: Important information here' },
                image: { src: '', alt: 'Image', objectFit: 'contain' }
            };
            return props[type] || {};
        }

        // Render component on canvas
        function renderComponent(comp) {
            const el = document.createElement('div');
            el.id = comp.id;
            el.className = 'dropped-component';
            el.style.left = comp.x + 'px';
            el.style.top = comp.y + 'px';
            el.style.width = comp.width + 'px';
            el.style.height = comp.height + 'px';

            el.innerHTML = getComponentHTML(comp);

            // Event listeners
            el.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) return;

                // First, disable any active text editing
                disableAllTextEditing();

                // Check if clicking on form inputs that are being edited (not readonly/disabled)
                const targetElement = e.target;
                const isFormElement = targetElement.tagName === 'INPUT' ||
                                      targetElement.tagName === 'TEXTAREA' ||
                                      targetElement.tagName === 'SELECT';

                // Only block drag if form element is being edited (not readonly/disabled)
                const isFormEditing = isFormElement &&
                                      !targetElement.hasAttribute('readonly') &&
                                      !targetElement.hasAttribute('disabled');

                // Don't start drag if element is currently being edited
                const isBeingEdited = targetElement.getAttribute('contenteditable') === 'true';

                if (isFormEditing || (isBeingEdited && targetElement.classList.contains('comp-label')) ||
                    (isBeingEdited && targetElement.classList.contains('comp-title'))) {
                    e.stopPropagation();
                    return;
                }

                e.stopPropagation();

                // Ctrl+click to add to selection
                if (e.ctrlKey || e.metaKey) {
                    selectComponent(comp.id, true);
                } else if (!selectedComponents.some(c => c.id === comp.id)) {
                    // If clicking on a non-selected component, select only it
                    selectComponent(comp.id);
                }

                // Check if this is on a label/title that supports double-click editing
                const isEditableText = targetElement.classList.contains('comp-label') ||
                                       targetElement.classList.contains('comp-title');

                // Check if this is a button component (single-click to edit, but can drag)
                const isButtonComponent = targetElement.classList.contains('comp-button');

                // Check if this is a form element (readonly/disabled) that needs special handling
                const isReadonlyFormElement = isFormElement && !isFormEditing;

                if (isButtonComponent) {
                    // For button component: wait for mousemove to determine drag or edit
                    // Clear any existing timeout
                    if (dragTimeout) clearTimeout(dragTimeout);

                    let hasMoved = false;
                    const startX = e.clientX;
                    const startY = e.clientY;

                    const checkMove = (moveE) => {
                        const dx = Math.abs(moveE.clientX - startX);
                        const dy = Math.abs(moveE.clientY - startY);

                        // If mouse moved more than 3 pixels, start drag
                        if (dx > 3 || dy > 3) {
                            hasMoved = true;
                            document.removeEventListener('mousemove', checkMove);
                            document.removeEventListener('mouseup', cleanup);
                            // Prevent text selection during drag
                            moveE.preventDefault();
                            targetElement.blur(); // Remove focus before drag
                            startDrag(e, comp.id);
                        }
                    };

                    const cleanup = () => {
                        document.removeEventListener('mousemove', checkMove);
                        document.removeEventListener('mouseup', cleanup);
                        // If no movement, focus the button for editing
                        if (!hasMoved) {
                            targetElement.focus();
                            // Move cursor to end
                            setTimeout(() => {
                                const range = document.createRange();
                                const sel = window.getSelection();
                                if (targetElement.childNodes.length > 0) {
                                    range.selectNodeContents(targetElement);
                                    range.collapse(false);
                                    sel.removeAllRanges();
                                    sel.addRange(range);
                                }
                            }, 10);
                        }
                    };

                    document.addEventListener('mousemove', checkMove);
                    document.addEventListener('mouseup', cleanup, { once: true });
                } else if (isEditableText || isReadonlyFormElement) {
                    // For editable text or readonly/disabled form elements, don't start drag immediately
                    // Wait for mousemove to determine if user is dragging or just clicking/double-clicking

                    // Clear any existing timeout
                    if (dragTimeout) clearTimeout(dragTimeout);

                    if (preventNextDrag) {
                        // Double-click just happened, don't start drag
                        preventNextDrag = false;
                        return;
                    }

                    let hasMoved = false;
                    const startX = e.clientX;
                    const startY = e.clientY;

                    const checkMove = (moveE) => {
                        const dx = Math.abs(moveE.clientX - startX);
                        const dy = Math.abs(moveE.clientY - startY);

                        // If mouse moved more than 3 pixels, start drag
                        if (dx > 3 || dy > 3) {
                            hasMoved = true;
                            document.removeEventListener('mousemove', checkMove);
                            document.removeEventListener('mouseup', cleanup);
                            if (!preventNextDrag) {
                                // Prevent text selection during drag
                                moveE.preventDefault();
                                startDrag(e, comp.id);
                            }
                        }
                    };

                    const cleanup = () => {
                        document.removeEventListener('mousemove', checkMove);
                        document.removeEventListener('mouseup', cleanup);
                        preventNextDrag = false;
                    };

                    document.addEventListener('mousemove', checkMove);
                    document.addEventListener('mouseup', cleanup, { once: true });
                } else {
                    // Non-editable elements: start drag immediately
                    if (!preventNextDrag) {
                        e.preventDefault(); // Prevent text selection
                        startDrag(e, comp.id);
                    }
                    preventNextDrag = false;
                }
            });

            el.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                // Only change selection if this component is NOT already part of multi-selection
                const isInMultiSelection = selectedComponents.some(c => c.id === comp.id) && selectedComponents.length > 1;
                if (!isInMultiSelection) {
                    selectComponent(comp.id);
                }
                showContextMenu(e.clientX, e.clientY);
            });

            // Prevent dropping new components on top of existing ones
            el.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                e.dataTransfer.dropEffect = 'none';
            });

            el.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
            });

            canvas.appendChild(el);
            addResizeHandles(el, comp);
        }

        function getComponentHTML(comp) {
            const p = comp.properties;

            switch (comp.type) {
                case 'label':
                    const labelText = (p.text || '').replace(/\n/g, '<br>');
                    return `<div class="comp-label" contenteditable="false" data-comp-id="${comp.id}" style="font-size: ${p.fontSize}px; font-weight: ${p.bold ? 'bold' : 'normal'}" ondblclick="enableTextEdit(this)" onblur="disableTextEdit(this)" onkeydown="handleLabelKeydown(event, this)">${labelText}</div>`;

                case 'title':
                    return `<div class="comp-title" contenteditable="false" data-comp-id="${comp.id}" style="font-size: ${p.fontSize}px" ondblclick="enableTextEdit(this)" onblur="disableTextEdit(this)" onkeydown="handleLabelKeydown(event, this)">${p.text}</div>`;

                case 'textbox':
                    return `<input type="text" class="comp-textbox" placeholder="${p.placeholder}" readonly ondblclick="enableInputEdit(this)" onblur="disableInputEdit(this)" onkeydown="handleInputKeydown(event, this)" style="width: 100%">`;

                case 'textarea':
                    return `<textarea class="comp-textarea" placeholder="${p.placeholder}" readonly ondblclick="enableInputEdit(this)" onblur="disableInputEdit(this)" style="width: 100%; height: 100%"></textarea>`;

                case 'datepicker':
                    return `<div class="comp-datepicker">
                        <input type="text" placeholder="${p.placeholder}" readonly ondblclick="enableInputEdit(this)" onblur="disableInputEdit(this)" onkeydown="handleInputKeydown(event, this)">
                        <div class="calendar-icon">üìÖ</div>
                    </div>`;

                case 'dropdown':
                    return `<div class="comp-dropdown-wrapper">
                        <select class="comp-dropdown" disabled ondblclick="enableSelectEdit(this)" onblur="disableSelectEdit(this)" onkeydown="handleSelectKeydown(event, this)">
                            <option value="">${p.placeholder}</option>
                            ${p.options.split(',').map(opt => `<option>${opt.trim()}</option>`).join('')}
                        </select>
                    </div>`;

                case 'checkbox':
                    return `<label class="comp-checkbox">
                        <input type="checkbox" ${p.checked ? 'checked' : ''}>
                        <span>${p.label}</span>
                    </label>`;

                case 'radio':
                    return `<label class="comp-radio">
                        <input type="radio" name="${p.group}">
                        <span>${p.label}</span>
                    </label>`;

                case 'button':
                    const btnClass = p.style === 'default' ? '' : p.style;
                    return `<button class="comp-button ${btnClass}" contenteditable="true" data-comp-id="${comp.id}" onblur="saveButtonText(this)" onkeydown="handleButtonKeydown(event, this)">${p.text}</button>`;

                case 'iconbutton':
                    const emojiIcons = {
                        edit: '‚úèÔ∏è',
                        delete: 'üóëÔ∏è',
                        view: 'üëÅÔ∏è',
                        save: 'üíæ',
                        add: '‚ûï',
                        search: 'üîç',
                        check: '‚úÖ',
                        cancel: '‚ùå',
                        print: 'üñ®Ô∏è',
                        copy: 'üìã',
                        refresh: 'üîÑ',
                        download: '‚¨áÔ∏è',
                        upload: '‚¨ÜÔ∏è',
                        settings: '‚öôÔ∏è',
                        user: 'üë§',
                        calendar: 'üìÖ',
                        filter: 'üîΩ',
                        sort: '‚ÜïÔ∏è'
                    };
                    const keenIcons = {
                        edit: 'ki-notepad-edit',
                        delete: 'ki-trash',
                        view: 'ki-eye',
                        save: 'ki-file-down',
                        add: 'ki-plus-squared',
                        search: 'ki-magnifier',
                        check: 'ki-check',
                        cancel: 'ki-cross',
                        print: 'ki-printer',
                        copy: 'ki-copy',
                        refresh: 'ki-arrows-circle',
                        download: 'ki-arrow-down',
                        upload: 'ki-arrow-up',
                        settings: 'ki-setting-2',
                        user: 'ki-user',
                        calendar: 'ki-calendar',
                        filter: 'ki-filter',
                        sort: 'ki-arrow-up-down'
                    };
                    const iconBtnClass = p.icon === 'delete' ? 'delete' : p.icon === 'view' ? 'view' : p.icon === 'save' ? 'save' : 'edit';

                    if (p.iconType === 'keenicons') {
                        const kiIcon = keenIcons[p.icon] || 'ki-notepad-edit';
                        return `<div class="comp-icon-btn ${iconBtnClass}" title="${p.tooltip}"><i class="ki-outline ${kiIcon}" style="font-size: 18px;"></i></div>`;
                    } else {
                        return `<div class="comp-icon-btn ${iconBtnClass}" title="${p.tooltip}">${emojiIcons[p.icon] || '‚úèÔ∏è'}</div>`;
                    }

                case 'table':
                    const cols = p.columns.split(',').map(c => c.trim());
                    const cellTexts = p.cellTexts || [];
                    const actionIconsList = p.actionIcons ? p.actionIcons.split(',').map(a => a.trim()) : [];
                    const actionPos = p.actionColumnPosition || 'right';

                    // Helper to generate action cell
                    const getActionCell = (isHeader) => {
                        if (!p.hasActionColumn) return '';
                        if (isHeader) {
                            return '<th style="width: 80px;"></th>';
                        }
                        const emojiMap = {
                            'edit': '‚úèÔ∏è',
                            'delete': 'üóëÔ∏è',
                            'view': 'üëÅÔ∏è',
                            'save': 'üíæ',
                            'add': '‚ûï',
                            'check': '‚úÖ',
                            'cancel': '‚ùå',
                            'print': 'üñ®Ô∏è',
                            'copy': 'üìã',
                            'refresh': 'üîÑ',
                            'download': '‚¨áÔ∏è',
                            'upload': '‚¨ÜÔ∏è',
                            'settings': '‚öôÔ∏è'
                        };
                        const keenIconMap = {
                            'edit': 'ki-notepad-edit',
                            'delete': 'ki-trash',
                            'view': 'ki-eye',
                            'save': 'ki-file-down',
                            'add': 'ki-plus-squared',
                            'check': 'ki-check',
                            'cancel': 'ki-cross',
                            'print': 'ki-printer',
                            'copy': 'ki-copy',
                            'refresh': 'ki-arrows-circle',
                            'download': 'ki-arrow-down',
                            'upload': 'ki-arrow-up',
                            'settings': 'ki-setting-2'
                        };
                        let actionsHTML = '<td style="text-align: center;">';
                        actionIconsList.forEach(action => {
                            if (p.actionIconType === 'keenicons') {
                                const kiIcon = keenIconMap[action] || 'ki-dots-horizontal';
                                actionsHTML += `<span style="cursor: pointer; margin: 0 4px;"><i class="ki-outline ${kiIcon}" style="font-size: 16px; color: var(--primary-color, #3b82f6);"></i></span>`;
                            } else {
                                actionsHTML += `<span style="cursor: pointer; margin: 0 2px;">${emojiMap[action] || action}</span>`;
                            }
                        });
                        actionsHTML += '</td>';
                        return actionsHTML;
                    };

                    // Helper to render cell content with styling
                    const renderCellContent = (rowIndex, colIndex) => {
                        const rowData = cellTexts[rowIndex];
                        if (!rowData) return '';
                        const cellData = rowData[colIndex];
                        if (!cellData) return '';

                        // Support new format { text, bold, underline }, string, and old parts format
                        if (typeof cellData === 'object' && 'text' in cellData) {
                            let style = '';
                            if (cellData.bold) style += 'font-weight: bold;';
                            if (cellData.underline) style += 'text-decoration: underline;';
                            return style ? `<span style="${style}">${cellData.text || ''}</span>` : (cellData.text || '');
                        }
                        if (typeof cellData === 'string') {
                            return cellData;
                        }
                        if (cellData.parts) {
                            return cellData.parts.map(p => p.text || '').join(' ');
                        }
                        return '';
                    };

                    let tableHTML = '<table class="comp-table"><thead><tr>';

                    // Header row
                    if (p.hasActionColumn && actionPos === 'left') tableHTML += getActionCell(true);
                    cols.forEach(col => tableHTML += `<th>${col}</th>`);
                    if (p.hasActionColumn && actionPos === 'right') tableHTML += getActionCell(true);

                    tableHTML += '</tr></thead><tbody>';

                    for (let i = 0; i < p.rows; i++) {
                        tableHTML += '<tr>';

                        if (p.hasActionColumn && actionPos === 'left') tableHTML += getActionCell(false);

                        cols.forEach((col, j) => {
                            const cellContent = renderCellContent(i, j);
                            tableHTML += `<td>${cellContent}</td>`;
                        });

                        if (p.hasActionColumn && actionPos === 'right') tableHTML += getActionCell(false);

                        tableHTML += '</tr>';
                    }
                    tableHTML += '</tbody></table>';
                    return tableHTML;

                case 'tabs':
                    const tabNames = p.tabs.split(',').map(t => t.trim());
                    let tabsHTML = '<div class="comp-tabs"><div class="tab-header">';
                    tabNames.forEach((tab, i) => {
                        tabsHTML += `<div class="tab-item ${i === p.activeTab ? 'active' : ''}">${tab}</div>`;
                    });
                    tabsHTML += '</div><div class="tab-content">Tab content area</div></div>';
                    return tabsHTML;

                case 'panel':
                    return `<div class="comp-panel" style="width: 100%; height: 100%">
                        <div class="panel-header">${p.title}</div>
                        <div class="panel-body"></div>
                    </div>`;

                case 'annotation':
                    return `<div class="comp-annotation">
                        <div style="position: relative; display: flex; align-items: center; gap: 8px;">
                            <div style="width: 80px; height: 2px; background: #3b82f6; position: relative;">
                                <div style="position: absolute; right: -6px; top: -4px; width: 0; height: 0; border-left: 8px solid #3b82f6; border-top: 5px solid transparent; border-bottom: 5px solid transparent;"></div>
                            </div>
                            <div class="annotation-box">${p.text}</div>
                        </div>
                    </div>`;

                case 'notebox':
                    return `<div class="annotation-box" style="width: 100%">${p.text}</div>`;

                case 'image':
                    if (p.src) {
                        return `<img class="comp-image" src="${p.src}" alt="${p.alt || 'Image'}" style="object-fit: ${p.objectFit || 'contain'}">`;
                    } else {
                        return `<div class="comp-image-placeholder" onclick="selectImageForComponent('${comp.id}')">
                            <span style="font-size: 32px;">üñºÔ∏è</span>
                            <span style="font-size: 12px; margin-top: 8px;">Click to select image</span>
                        </div>`;
                    }

                default:
                    return `<div>${comp.type}</div>`;
            }
        }

        function addResizeHandles(el, comp) {
            const handles = ['se', 'e', 's'];
            handles.forEach(pos => {
                const handle = document.createElement('div');
                handle.className = `resize-handle ${pos}`;
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startResize(e, comp.id, pos);
                });
                el.appendChild(handle);
            });
        }

        function startResize(e, compId, handlePos) {
            isResizing = true;
            resizeHandle = handlePos;
            const comp = components.find(c => c.id === compId);
            resizeStart = {
                x: e.clientX,
                y: e.clientY,
                width: comp.width,
                height: comp.height
            };
            selectComponent(compId);

            const onMouseMove = (e) => {
                if (!isResizing) return;

                const dx = e.clientX - resizeStart.x;
                const dy = e.clientY - resizeStart.y;

                if (resizeHandle.includes('e')) {
                    let newWidth = Math.max(50, resizeStart.width + dx);
                    comp.width = snapToGrid(newWidth);
                }
                if (resizeHandle.includes('s')) {
                    let newHeight = Math.max(30, resizeStart.height + dy);
                    comp.height = snapToGrid(newHeight);
                }

                updateComponentElement(comp);
                autoResizeCanvas();
            };

            const onMouseUp = () => {
                isResizing = false;
                saveHistory();
                autoResizeCanvas();
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
            };

            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
        }

        // Select component
        function selectComponent(id, addToSelection = false) {
            if (!addToSelection) {
                // Clear all selections
                document.querySelectorAll('.dropped-component').forEach(el => {
                    el.classList.remove('selected');
                    el.classList.remove('multi-selected');
                });
                selectedComponents = [];
            }

            if (id) {
                const el = document.getElementById(id);
                const comp = components.find(c => c.id === id);

                if (addToSelection) {
                    // Toggle selection
                    const idx = selectedComponents.findIndex(c => c.id === id);
                    if (idx >= 0) {
                        selectedComponents.splice(idx, 1);
                        if (el) el.classList.remove('multi-selected');
                    } else {
                        if (comp) selectedComponents.push(comp);
                        if (el) el.classList.add('multi-selected');
                    }
                    // Update primary selection
                    selectedComponent = selectedComponents.length > 0 ? selectedComponents[0] : null;
                } else {
                    if (el) el.classList.add('selected');
                    selectedComponent = comp;
                    selectedComponents = comp ? [comp] : [];
                }
                showProperties(selectedComponent);
            } else {
                selectedComponent = null;
                selectedComponents = [];
                showProperties(null);
            }
        }

        // Clear all selections
        function clearSelection() {
            document.querySelectorAll('.dropped-component').forEach(el => {
                el.classList.remove('selected');
                el.classList.remove('multi-selected');
            });
            selectedComponent = null;
            selectedComponents = [];
            showProperties(null);
        }

        // Select multiple components (from marquee)
        function selectMultipleComponents(compIds) {
            clearSelection();
            compIds.forEach((id, index) => {
                const el = document.getElementById(id);
                const comp = components.find(c => c.id === id);
                if (el && comp) {
                    el.classList.add('multi-selected');
                    selectedComponents.push(comp);
                }
            });
            if (selectedComponents.length > 0) {
                selectedComponent = selectedComponents[0];
                showProperties(selectedComponent);
            }
        }

        // Create drag image element (clone of the component)
        function createDragImage(comp, el, initialX, initialY) {
            // Clone the component element
            const dragImage = el.cloneNode(true);
            dragImage.className = 'drag-image';
            dragImage.id = 'drag-image-' + comp.id;
            dragImage.style.left = (initialX !== undefined ? initialX : comp.x) + 'px';
            dragImage.style.top = (initialY !== undefined ? initialY : comp.y) + 'px';
            dragImage.style.width = comp.width + 'px';
            dragImage.style.height = comp.height + 'px';

            // Remove resize handles from clone
            dragImage.querySelectorAll('.resize-handle').forEach(h => h.remove());

            canvas.appendChild(dragImage);
            return dragImage;
        }

        // Legacy alias for compatibility
        function createDragGhost(comp, el, initialX, initialY) {
            return createDragImage(comp, el, initialX, initialY);
        }

        // Remove drag image element
        function removeDragImage(compId) {
            const dragImage = document.getElementById('drag-image-' + compId);
            if (dragImage) dragImage.remove();
        }

        // Remove all drag images
        function removeAllDragImages() {
            document.querySelectorAll('.drag-image').forEach(img => img.remove());
        }

        // Drag component
        function startDrag(e, compId) {
            const comp = components.find(c => c.id === compId);
            const el = document.getElementById(compId);
            const rect = el.getBoundingClientRect();

            // Check if this component is part of multi-selection
            const isInMultiSelection = selectedComponents.some(c => c.id === compId) && selectedComponents.length > 1;

            if (isInMultiSelection) {
                // Multi-drag mode
                isMultiDragging = true;
                isDragging = false;

                // Get canvas screen position
                const canvasRect = canvas.getBoundingClientRect();

                // Calculate mouse position on canvas
                const mouseCanvasX = e.clientX - canvasRect.left;
                const mouseCanvasY = e.clientY - canvasRect.top;

                // Create ghosts for all selected components
                // Each ghost maintains relative offset from mouse position
                const ghostData = selectedComponents.map(c => {
                    const compEl = document.getElementById(c.id);
                    compEl.classList.add('dragging');

                    // Calculate offset from mouse to this component's original position
                    const offsetX = c.x - mouseCanvasX;
                    const offsetY = c.y - mouseCanvasY;

                    // Initial ghost position: mouse position + offset (keeps relative positions)
                    const initialX = mouseCanvasX + offsetX;
                    const initialY = mouseCanvasY + offsetY;

                    const ghost = createDragGhost(c, compEl, initialX, initialY);
                    return {
                        comp: c,
                        ghost: ghost,
                        el: compEl,
                        offsetX: offsetX,
                        offsetY: offsetY,
                        newX: initialX,
                        newY: initialY
                    };
                });

                const onMouseMove = (moveE) => {
                    if (!isMultiDragging) return;

                    // Prevent text selection during drag
                    moveE.preventDefault();
                    window.getSelection().removeAllRanges();

                    // Get fresh canvas position
                    const canvasRect = canvas.getBoundingClientRect();

                    // Calculate current mouse position on canvas
                    const currentMouseX = moveE.clientX - canvasRect.left;
                    const currentMouseY = moveE.clientY - canvasRect.top;

                    ghostData.forEach(item => {
                        // Ghost position = mouse position + offset to maintain relative positions
                        let newX = currentMouseX + item.offsetX;
                        let newY = currentMouseY + item.offsetY;

                        // Keep minimum bounds
                        newX = Math.max(0, newX);
                        newY = Math.max(0, newY);

                        // Apply snap to grid
                        newX = snapToGrid(newX);
                        newY = snapToGrid(newY);

                        // Update ghost position
                        item.ghost.style.left = newX + 'px';
                        item.ghost.style.top = newY + 'px';
                        item.newX = newX;
                        item.newY = newY;
                    });
                };

                const onMouseUp = () => {
                    isMultiDragging = false;

                    // Move components to ghost positions
                    ghostData.forEach(item => {
                        if (item.newX !== undefined) {
                            item.comp.x = item.newX;
                            item.comp.y = item.newY;
                            item.el.style.left = item.comp.x + 'px';
                            item.el.style.top = item.comp.y + 'px';
                        }
                        item.el.classList.remove('dragging');
                        item.ghost.remove();
                    });

                    multiDragOffsets = [];
                    saveHistory();
                    autoResizeCanvas();
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            } else {
                // Single drag mode
                isDragging = true;

                // Get canvas position
                const canvasRect = canvas.getBoundingClientRect();

                // Calculate mouse position on canvas
                const mouseCanvasX = e.clientX - canvasRect.left;
                const mouseCanvasY = e.clientY - canvasRect.top;

                // Calculate offset from mouse to component's current position
                const offsetX = comp.x - mouseCanvasX;
                const offsetY = comp.y - mouseCanvasY;

                // Create drag image at component's current position (not mouse position)
                const dragImage = createDragImage(comp, el, comp.x, comp.y);
                el.classList.add('dragging');

                let newX = comp.x;
                let newY = comp.y;

                const onMouseMove = (moveE) => {
                    if (!isDragging) return;

                    // Prevent text selection during drag
                    moveE.preventDefault();
                    window.getSelection().removeAllRanges();

                    // Get fresh canvas position
                    const canvasRect = canvas.getBoundingClientRect();

                    // Calculate current mouse position on canvas
                    const currentMouseX = moveE.clientX - canvasRect.left;
                    const currentMouseY = moveE.clientY - canvasRect.top;

                    // Calculate new position: mouse position + offset
                    newX = currentMouseX + offsetX;
                    newY = currentMouseY + offsetY;

                    // Keep minimum bounds (allow expansion to the right and bottom)
                    newX = Math.max(0, newX);
                    newY = Math.max(0, newY);

                    // Apply snap to grid
                    newX = snapToGrid(newX);
                    newY = snapToGrid(newY);

                    // Update drag image position
                    dragImage.style.left = newX + 'px';
                    dragImage.style.top = newY + 'px';
                };

                const onMouseUp = () => {
                    isDragging = false;

                    // Move component to drag image position
                    comp.x = newX;
                    comp.y = newY;
                    el.style.left = comp.x + 'px';
                    el.style.top = comp.y + 'px';

                    // Remove drag image and dragging class
                    el.classList.remove('dragging');
                    dragImage.remove();

                    saveHistory();
                    autoResizeCanvas();
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                };

                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            }
        }

        // Get/Set canvas size from hidden inputs
        function getCanvasWidth() {
            return parseInt(document.getElementById('canvasWidthHidden').value) || 1200;
        }

        function getCanvasHeight() {
            return parseInt(document.getElementById('canvasHeightHidden').value) || 800;
        }

        function setCanvasWidthValue(val) {
            document.getElementById('canvasWidthHidden').value = val;
            const visibleInput = document.getElementById('canvasWidthVisible');
            if (visibleInput) visibleInput.value = val;
        }

        function setCanvasHeightValue(val) {
            document.getElementById('canvasHeightHidden').value = val;
            const visibleInput = document.getElementById('canvasHeightVisible');
            if (visibleInput) visibleInput.value = val;
        }

        // Get/Set screen name and title from hidden inputs
        function getScreenName() {
            return document.getElementById('screenNameHidden').value || 'sc-new';
        }

        function getScreenTitle() {
            return document.getElementById('screenTitleHidden').value || '‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠‡πÉ‡∏´‡∏°‡πà';
        }

        function setScreenNameValue(val) {
            document.getElementById('screenNameHidden').value = val;
            const visibleInput = document.getElementById('screenNameVisible');
            if (visibleInput) visibleInput.value = val;
        }

        function setScreenTitleValue(val) {
            document.getElementById('screenTitleHidden').value = val;
            const visibleInput = document.getElementById('screenTitleVisible');
            if (visibleInput) visibleInput.value = val;
        }

        // Show canvas properties
        function showCanvasProperties() {
            const canvasWidth = getCanvasWidth();
            const canvasHeight = getCanvasHeight();
            const screenName = getScreenName();
            const screenTitle = getScreenTitle();

            let html = `
                <div class="property-group" style="margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: #1e293b; margin-bottom: 12px;">
                        üìã Screen Info
                    </div>
                </div>
                <div class="property-group">
                    <label>Screen ID</label>
                    <input type="text" id="screenNameVisible" value="${screenName}" placeholder="sc-xxx" oninput="updateScreenInfo()">
                </div>
                <div class="property-group">
                    <label>Screen Title</label>
                    <input type="text" id="screenTitleVisible" value="${screenTitle}" placeholder="Screen Title" oninput="updateScreenInfo()">
                </div>
                <hr style="margin: 16px 0; border: none; border-top: 1px solid #e2e8f0;">
                <div class="property-group" style="margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: #1e293b; margin-bottom: 12px;">
                        üñºÔ∏è Canvas
                    </div>
                </div>
                <div class="property-group">
                    <label>Theme</label>
                    <select id="themeSelect" onchange="changeTheme(this.value)">
                        <option value="default" ${currentTheme === 'default' ? 'selected' : ''}>Default</option>
                        <option value="aj" ${currentTheme === 'aj' ? 'selected' : ''}>AJ Style (Teal)</option>
                        <option value="metronic" ${currentTheme === 'metronic' ? 'selected' : ''}>Metronic (KeenThemes)</option>
                        <option value="blue" ${currentTheme === 'blue' ? 'selected' : ''}>Blue</option>
                        <option value="purple" ${currentTheme === 'purple' ? 'selected' : ''}>Purple</option>
                        <option value="gray" ${currentTheme === 'gray' ? 'selected' : ''}>Gray</option>
                    </select>
                </div>
                <div class="property-row">
                    <div class="property-group">
                        <label>Width</label>
                        <input type="number" id="canvasWidthVisible" value="${canvasWidth}" min="400" step="50" onchange="updateCanvasSize()">
                    </div>
                    <div class="property-group">
                        <label>Height</label>
                        <input type="number" id="canvasHeightVisible" value="${canvasHeight}" min="300" step="50" onchange="updateCanvasSize()">
                    </div>
                </div>
                <div class="property-group">
                    <button class="toolbar-btn" onclick="fitCanvasToComponents()" style="width: 100%;">
                        üìê Fit to Components
                    </button>
                </div>
                <hr style="margin: 16px 0; border: none; border-top: 1px solid #e2e8f0;">
                <div class="property-group" style="margin-bottom: 12px;">
                    <div style="font-size: 14px; font-weight: 600; color: #1e293b; margin-bottom: 12px;">
                        ‚äû Grid & Guides
                    </div>
                </div>
                <div class="property-group">
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; text-transform: none; font-weight: normal;">
                            <input type="checkbox" id="showGridCheck" onchange="toggleGrid()" ${gridSettings.showGrid ? 'checked' : ''}>
                            Show Grid
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; text-transform: none; font-weight: normal;">
                            <input type="checkbox" id="showRulersCheck" onchange="toggleRulers()" ${gridSettings.showRulers ? 'checked' : ''}>
                            Show Rulers
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; text-transform: none; font-weight: normal;">
                            <input type="checkbox" id="snapToGridCheck" onchange="toggleSnapToGrid()" ${gridSettings.snapToGrid ? 'checked' : ''}>
                            Snap to Grid
                        </label>
                    </div>
                </div>
                <div class="property-group">
                    <label>Grid Size</label>
                    <select onchange="setGridSize(this.value)">
                        <option value="small" ${gridSettings.gridSize === 'small' ? 'selected' : ''}>Small (10px)</option>
                        <option value="medium" ${gridSettings.gridSize === 'medium' ? 'selected' : ''}>Medium (50px)</option>
                        <option value="large" ${gridSettings.gridSize === 'large' ? 'selected' : ''}>Large (100px)</option>
                    </select>
                </div>
            `;

            propertiesContent.innerHTML = html;
        }

        // Update screen info from visible inputs
        function updateScreenInfo() {
            const nameInput = document.getElementById('screenNameVisible');
            const titleInput = document.getElementById('screenTitleVisible');
            if (nameInput) setScreenNameValue(nameInput.value);
            if (titleInput) setScreenTitleValue(titleInput.value);
            markDocumentDirty();
        }

        // Update canvas size from visible inputs
        function updateCanvasSize() {
            const widthInput = document.getElementById('canvasWidthVisible');
            const heightInput = document.getElementById('canvasHeightVisible');
            if (widthInput) setCanvasWidthValue(widthInput.value);
            if (heightInput) setCanvasHeightValue(heightInput.value);
            setCanvasSize();
            markDocumentDirty();
        }

        // Show properties panel
        function showProperties(comp) {
            if (!comp) {
                showCanvasProperties();
                return;
            }

            let html = `
                <div class="property-group">
                    <label>Type</label>
                    <input type="text" value="${comp.type}" disabled>
                </div>
                <div class="property-row">
                    <div class="property-group">
                        <label>X</label>
                        <input type="number" id="prop_x" value="${Math.round(comp.x)}" onchange="updatePosition('x', this.value)">
                    </div>
                    <div class="property-group">
                        <label>Y</label>
                        <input type="number" id="prop_y" value="${Math.round(comp.y)}" onchange="updatePosition('y', this.value)">
                    </div>
                </div>
                <div class="property-row">
                    <div class="property-group">
                        <label>Width</label>
                        <input type="number" id="prop_width" value="${comp.width}" onchange="updateSize('width', this.value)">
                    </div>
                    <div class="property-group">
                        <label>Height</label>
                        <input type="number" id="prop_height" value="${comp.height}" onchange="updateSize('height', this.value)">
                    </div>
                </div>
            `;

            // Add type-specific properties
            html += getPropertiesHTML(comp);

            propertiesContent.innerHTML = html;
        }

        function getPropertiesHTML(comp) {
            const p = comp.properties;
            let html = '<hr style="margin: 16px 0; border: none; border-top: 1px solid #e2e8f0;">';

            switch (comp.type) {
                case 'label':
                    html += `
                        <div class="property-group">
                            <label>Text</label>
                            <textarea rows="3" onchange="updateProp('text', this.value)">${p.text}</textarea>
                        </div>
                        <div class="property-group">
                            <label>Font Size</label>
                            <input type="number" value="${p.fontSize}" onchange="updateProp('fontSize', parseInt(this.value))">
                        </div>
                        <div class="property-group">
                            <label>Bold</label>
                            <select onchange="updateProp('bold', this.value === 'true')">
                                <option value="false" ${!p.bold ? 'selected' : ''}>No</option>
                                <option value="true" ${p.bold ? 'selected' : ''}>Yes</option>
                            </select>
                    `;
                    break;

                case 'title':
                    html += `
                        <div class="property-group">
                            <label>Text</label>
                            <input type="text" value="${p.text}" onchange="updateProp('text', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Font Size</label>
                            <input type="number" value="${p.fontSize}" onchange="updateProp('fontSize', parseInt(this.value))">
                        </div>
                    `;
                    break;

                case 'textbox':
                case 'textarea':
                    html += `
                        <div class="property-group">
                            <label>Field Name</label>
                            <input type="text" value="${p.fieldName || ''}" onchange="updateProp('fieldName', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Placeholder</label>
                            <input type="text" value="${p.placeholder}" onchange="updateProp('placeholder', this.value)">
                        </div>
                    `;
                    if (comp.type === 'textbox') {
                        html += `
                            <div class="property-group">
                                <label>Required</label>
                                <select onchange="updateProp('required', this.value === 'true')">
                                    <option value="false" ${!p.required ? 'selected' : ''}>No</option>
                                    <option value="true" ${p.required ? 'selected' : ''}>Yes</option>
                                </select>
                            </div>
                        `;
                    }
                    break;

                case 'datepicker':
                    html += `
                        <div class="property-group">
                            <label>Field Name</label>
                            <input type="text" value="${p.fieldName || ''}" onchange="updateProp('fieldName', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Placeholder</label>
                            <input type="text" value="${p.placeholder}" onchange="updateProp('placeholder', this.value)">
                        </div>
                    `;
                    break;

                case 'dropdown':
                    html += `
                        <div class="property-group">
                            <label>Field Name</label>
                            <input type="text" value="${p.fieldName || ''}" onchange="updateProp('fieldName', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Placeholder</label>
                            <input type="text" value="${p.placeholder}" onchange="updateProp('placeholder', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Options (comma separated)</label>
                            <textarea rows="3" onchange="updateProp('options', this.value)">${p.options}</textarea>
                        </div>
                    `;
                    break;

                case 'checkbox':
                case 'radio':
                    html += `
                        <div class="property-group">
                            <label>Field Name</label>
                            <input type="text" value="${p.fieldName || ''}" onchange="updateProp('fieldName', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Label</label>
                            <input type="text" value="${p.label}" onchange="updateProp('label', this.value)">
                        </div>
                    `;
                    if (comp.type === 'radio') {
                        html += `
                            <div class="property-group">
                                <label>Group Name</label>
                                <input type="text" value="${p.group}" onchange="updateProp('group', this.value)">
                            </div>
                        `;
                    }
                    break;

                case 'button':
                    html += `
                        <div class="property-group">
                            <label>Text</label>
                            <input type="text" value="${p.text}" onchange="updateProp('text', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Style</label>
                            <select onchange="updateProp('style', this.value)">
                                <option value="default" ${p.style === 'default' ? 'selected' : ''}>Default</option>
                                <option value="primary" ${p.style === 'primary' ? 'selected' : ''}>Primary (Blue)</option>
                                <option value="success" ${p.style === 'success' ? 'selected' : ''}>Success (Green)</option>
                                <option value="danger" ${p.style === 'danger' ? 'selected' : ''}>Danger (Red)</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Action</label>
                            <input type="text" value="${p.action || ''}" onchange="updateProp('action', this.value)">
                        </div>
                    `;
                    break;

                case 'iconbutton':
                    html += `
                        <div class="property-group">
                            <label>Icon Type</label>
                            <select onchange="updateProp('iconType', this.value)">
                                <option value="emoji" ${(p.iconType || 'emoji') === 'emoji' ? 'selected' : ''}>Emoji</option>
                                <option value="keenicons" ${p.iconType === 'keenicons' ? 'selected' : ''}>KeenIcons</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Icon</label>
                            <select onchange="updateProp('icon', this.value)">
                                <option value="edit" ${p.icon === 'edit' ? 'selected' : ''}>Edit</option>
                                <option value="delete" ${p.icon === 'delete' ? 'selected' : ''}>Delete</option>
                                <option value="view" ${p.icon === 'view' ? 'selected' : ''}>View</option>
                                <option value="save" ${p.icon === 'save' ? 'selected' : ''}>Save</option>
                                <option value="add" ${p.icon === 'add' ? 'selected' : ''}>Add</option>
                                <option value="search" ${p.icon === 'search' ? 'selected' : ''}>Search</option>
                                <option value="check" ${p.icon === 'check' ? 'selected' : ''}>Check</option>
                                <option value="cancel" ${p.icon === 'cancel' ? 'selected' : ''}>Cancel</option>
                                <option value="print" ${p.icon === 'print' ? 'selected' : ''}>Print</option>
                                <option value="copy" ${p.icon === 'copy' ? 'selected' : ''}>Copy</option>
                                <option value="refresh" ${p.icon === 'refresh' ? 'selected' : ''}>Refresh</option>
                                <option value="download" ${p.icon === 'download' ? 'selected' : ''}>Download</option>
                                <option value="upload" ${p.icon === 'upload' ? 'selected' : ''}>Upload</option>
                                <option value="settings" ${p.icon === 'settings' ? 'selected' : ''}>Settings</option>
                                <option value="user" ${p.icon === 'user' ? 'selected' : ''}>User</option>
                                <option value="calendar" ${p.icon === 'calendar' ? 'selected' : ''}>Calendar</option>
                                <option value="filter" ${p.icon === 'filter' ? 'selected' : ''}>Filter</option>
                                <option value="sort" ${p.icon === 'sort' ? 'selected' : ''}>Sort</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Tooltip</label>
                            <input type="text" value="${p.tooltip}" onchange="updateProp('tooltip', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Action</label>
                            <input type="text" value="${p.action || ''}" onchange="updateProp('action', this.value)">
                        </div>
                    `;
                    break;

                case 'table':
                    html += `
                        <div class="property-group">
                            <label>Field Name</label>
                            <input type="text" value="${p.fieldName || ''}" onchange="updateProp('fieldName', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Columns (comma separated)</label>
                            <textarea rows="3" onchange="updateProp('columns', this.value)">${p.columns}</textarea>
                        </div>
                        <div class="property-group">
                            <label>Sample Rows</label>
                            <input type="number" value="${p.rows}" min="1" max="10" onchange="updateProp('rows', parseInt(this.value))">
                        </div>
                        <hr style="margin: 12px 0; border: none; border-top: 1px solid #e2e8f0;">
                        <div class="property-group">
                            <label>Cell Contents</label>
                            <button class="toolbar-btn" onclick="openCellTextEditor()" style="width: 100%;">
                                üìù Edit Cell Texts
                            </button>
                            <small style="color: #64748b; font-size: 11px;">
                                Add styled text, icons to each cell
                            </small>
                        </div>
                        <hr style="margin: 12px 0; border: none; border-top: 1px solid #e2e8f0;">
                        <div class="property-group">
                            <label>Show Action Column</label>
                            <select onchange="updateProp('hasActionColumn', this.value === 'true')">
                                <option value="false" ${!p.hasActionColumn ? 'selected' : ''}>No</option>
                                <option value="true" ${p.hasActionColumn ? 'selected' : ''}>Yes</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Action Column Position</label>
                            <select onchange="updateProp('actionColumnPosition', this.value)">
                                <option value="left" ${(p.actionColumnPosition || 'left') === 'left' ? 'selected' : ''}>Left</option>
                                <option value="right" ${p.actionColumnPosition === 'right' ? 'selected' : ''}>Right</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Action Icon Type</label>
                            <select onchange="updateProp('actionIconType', this.value)">
                                <option value="emoji" ${(p.actionIconType || 'emoji') === 'emoji' ? 'selected' : ''}>Emoji</option>
                                <option value="keenicons" ${p.actionIconType === 'keenicons' ? 'selected' : ''}>KeenIcons</option>
                            </select>
                        </div>
                        <div class="property-group">
                            <label>Action Icons (comma separated)</label>
                            <textarea rows="2" onchange="updateProp('actionIcons', this.value)" placeholder="edit, delete, view">${p.actionIcons || ''}</textarea>
                            <small style="color: #64748b; font-size: 11px;">Options: edit, delete, view, save, add, check, cancel, print, copy, refresh, download, upload, settings</small>
                        </div>
                    `;
                    break;

                case 'tabs':
                    html += `
                        <div class="property-group">
                            <label>Tab Names (comma separated)</label>
                            <textarea rows="2" onchange="updateProp('tabs', this.value)">${p.tabs}</textarea>
                        </div>
                        <div class="property-group">
                            <label>Active Tab Index</label>
                            <input type="number" value="${p.activeTab}" min="0" onchange="updateProp('activeTab', parseInt(this.value))">
                        </div>
                    `;
                    break;

                case 'panel':
                    html += `
                        <div class="property-group">
                            <label>Title</label>
                            <input type="text" value="${p.title}" onchange="updateProp('title', this.value)">
                        </div>
                    `;
                    break;

                case 'annotation':
                case 'notebox':
                    html += `
                        <div class="property-group">
                            <label>Note Text</label>
                            <textarea rows="3" onchange="updateProp('text', this.value)">${p.text}</textarea>
                        </div>
                    `;
                    break;

                case 'image':
                    html += `
                        <div class="property-group">
                            <label>Image</label>
                            <button class="toolbar-btn" onclick="selectImageForComponent('${comp.id}')" style="width: 100%;">
                                üì∑ ${p.src ? 'Change Image' : 'Select Image'}
                            </button>
                        </div>
                        ${p.src ? `
                        <div class="property-group">
                            <img src="${p.src}" style="max-width: 100%; max-height: 100px; border-radius: 4px; border: 1px solid #e2e8f0;">
                        </div>
                        ` : ''}
                        <div class="property-group">
                            <label>Alt Text</label>
                            <input type="text" value="${p.alt || ''}" onchange="updateProp('alt', this.value)">
                        </div>
                        <div class="property-group">
                            <label>Object Fit</label>
                            <select onchange="updateProp('objectFit', this.value)">
                                <option value="contain" ${(p.objectFit || 'contain') === 'contain' ? 'selected' : ''}>Contain</option>
                                <option value="cover" ${p.objectFit === 'cover' ? 'selected' : ''}>Cover</option>
                                <option value="fill" ${p.objectFit === 'fill' ? 'selected' : ''}>Fill</option>
                                <option value="none" ${p.objectFit === 'none' ? 'selected' : ''}>None (Original)</option>
                            </select>
                        </div>
                    `;
                    break;
            }

            return html;
        }

        function updatePosition(prop, value) {
            if (!selectedComponent) return;
            selectedComponent[prop] = parseInt(value);
            updateComponentElement(selectedComponent);
            saveHistory();
        }

        function updateSize(prop, value) {
            if (!selectedComponent) return;
            selectedComponent[prop] = parseInt(value);
            updateComponentElement(selectedComponent);
            saveHistory();
        }

        function updateProp(prop, value) {
            if (!selectedComponent) return;
            selectedComponent.properties[prop] = value;
            updateComponentElement(selectedComponent);
            showProperties(selectedComponent);
            saveHistory();
        }

        // Helper function to update rowTexts from textarea input
        function updateRowTexts(value) {
            if (!selectedComponent) return;
            try {
                const lines = value.trim().split('\n').filter(l => l.trim());
                const rowTexts = lines.map(line => JSON.parse(line.trim()));
                updateProp('rowTexts', rowTexts);
            } catch (e) {
                showToast('Invalid JSON format', 'error');
            }
        }

        // Helper function to format rowTexts array for display in textarea
        function formatRowTextsForDisplay(rowTexts) {
            if (!rowTexts || !Array.isArray(rowTexts) || rowTexts.length === 0) return '';
            return rowTexts.map(r => JSON.stringify(r)).join('\n');
        }

        // Cell Text Editor state
        let cellTextEditorData = [];
        let cellTextEditorCols = [];
        let cellTextEditorRows = 0;

        function openCellTextEditor() {
            if (!selectedComponent || selectedComponent.type !== 'table') return;

            const p = selectedComponent.properties;
            cellTextEditorCols = p.columns.split(',').map(c => c.trim());
            cellTextEditorRows = p.rows;

            // Copy current cellTexts to editor state as objects { text, bold, underline }
            cellTextEditorData = [];
            const existingData = p.cellTexts || [];

            for (let i = 0; i < cellTextEditorRows; i++) {
                cellTextEditorData[i] = [];
                for (let j = 0; j < cellTextEditorCols.length; j++) {
                    const cellValue = existingData[i] && existingData[i][j];
                    // Support old format (object with parts), string format, and new format
                    if (cellValue && typeof cellValue === 'object' && 'text' in cellValue) {
                        // New format { text, bold, underline }
                        cellTextEditorData[i][j] = { ...cellValue };
                    } else if (typeof cellValue === 'string') {
                        cellTextEditorData[i][j] = { text: cellValue, bold: false, underline: false };
                    } else if (cellValue && cellValue.parts && cellValue.parts.length > 0) {
                        // Convert old parts format
                        const firstPart = cellValue.parts[0];
                        cellTextEditorData[i][j] = {
                            text: cellValue.parts.map(p => p.text || '').join(' '),
                            bold: firstPart.bold || false,
                            underline: firstPart.underline || false
                        };
                    } else {
                        cellTextEditorData[i][j] = { text: '', bold: false, underline: false };
                    }
                }
            }

            renderCellTextEditor();
            document.getElementById('cellTextEditorModal').classList.remove('hidden');
        }

        function closeCellTextEditor() {
            document.getElementById('cellTextEditorModal').classList.add('hidden');
        }

        function renderCellTextEditor() {
            const container = document.getElementById('cellTextEditorContent');

            let html = '<table class="cell-editor-table"><thead><tr>';
            html += '<th style="width: 40px;">#</th>';
            cellTextEditorCols.forEach(col => {
                html += `<th>${col}</th>`;
            });
            html += '</tr></thead><tbody>';

            for (let i = 0; i < cellTextEditorRows; i++) {
                html += `<tr><td class="cell-editor-row-num">${i + 1}</td>`;

                for (let j = 0; j < cellTextEditorCols.length; j++) {
                    const cell = cellTextEditorData[i][j] || { text: '', bold: false, underline: false };
                    html += `<td><div class="cell-input-group">
                        <input type="text" class="cell-text-input" value="${escapeHtmlForEditor(cell.text || '')}"
                               onchange="updateCellText(${i}, ${j}, 'text', this.value)"
                               placeholder="Text...">
                        <label title="Bold"><input type="checkbox" ${cell.bold ? 'checked' : ''}
                               onchange="updateCellText(${i}, ${j}, 'bold', this.checked)">B</label>
                        <label title="Underline"><input type="checkbox" ${cell.underline ? 'checked' : ''}
                               onchange="updateCellText(${i}, ${j}, 'underline', this.checked)">U</label>
                    </div></td>`;
                }

                html += '</tr>';
            }

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        function escapeHtmlForEditor(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateCellText(rowIndex, colIndex, field, value) {
            cellTextEditorData[rowIndex][colIndex][field] = value;
        }

        function applyCellTexts() {
            updateProp('cellTexts', cellTextEditorData);
            closeCellTextEditor();
        }

        // Save label text from inline editing
        // Disable all text editing (called before any interaction)
        function disableAllTextEditing() {
            // Find all elements currently being edited
            document.querySelectorAll('[contenteditable="true"]').forEach(el => {
                if (el.classList.contains('comp-label') || el.classList.contains('comp-title')) {
                    disableTextEdit(el);
                }
            });
            // Blur any focused input/textarea/select
            document.querySelectorAll('.comp-textbox, .comp-textarea, .comp-datepicker input, .comp-dropdown').forEach(el => {
                if (document.activeElement === el) {
                    el.blur();
                }
            });
        }

        // Enable input/textarea editing (double-click)
        function enableInputEdit(el) {
            preventNextDrag = true;
            el.removeAttribute('readonly');
            el.focus();
            // Move cursor to end
            setTimeout(() => {
                if (el.setSelectionRange) {
                    const len = el.value.length;
                    el.setSelectionRange(len, len);
                }
            }, 10);
        }

        // Disable input/textarea editing (blur)
        function disableInputEdit(el) {
            el.setAttribute('readonly', 'readonly');
            preventNextDrag = false;
        }

        // Enable select editing (double-click)
        function enableSelectEdit(el) {
            preventNextDrag = true;
            el.removeAttribute('disabled');
            el.focus();
        }

        // Disable select editing (blur)
        function disableSelectEdit(el) {
            el.setAttribute('disabled', 'disabled');
            preventNextDrag = false;
        }

        // Enable text editing mode (double-click)
        function enableTextEdit(el) {
            if (!el) return;
            // Prevent drag from starting
            preventNextDrag = true;
            if (dragTimeout) {
                clearTimeout(dragTimeout);
                dragTimeout = null;
            }

            el.contentEditable = 'true';
            el.setAttribute('contenteditable', 'true');
            el.focus();
            // Move cursor to end of text instead of selecting all
            setTimeout(() => {
                const range = document.createRange();
                const sel = window.getSelection();

                // Move cursor to the end
                range.selectNodeContents(el);
                range.collapse(false); // false = collapse to end

                sel.removeAllRanges();
                sel.addRange(range);
            }, 10);
        }

        // Disable text editing mode and save (blur)
        function disableTextEdit(el) {
            if (!el) return;
            // Only disable if currently editable
            if (el.getAttribute('contenteditable') === 'false') return;

            el.contentEditable = 'false';
            el.setAttribute('contenteditable', 'false');
            saveLabelText(el);
            // Remove focus and clear selection
            if (document.activeElement === el) {
                el.blur();
            }
            window.getSelection().removeAllRanges();
        }

        function saveLabelText(el) {
            const compId = el.dataset.compId;
            const comp = components.find(c => c.id === compId);
            if (!comp) return;

            // Convert <br> and <div> back to \n for storage
            let text = el.innerHTML
                .replace(/<div>/gi, '\n')
                .replace(/<\/div>/gi, '')
                .replace(/<br\s*\/?>/gi, '\n')
                .replace(/&nbsp;/g, ' ');

            // Remove HTML tags and decode entities
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = text;
            text = tempDiv.textContent || tempDiv.innerText || '';

            if (comp.properties.text !== text) {
                comp.properties.text = text;

                // Update the display text without re-rendering entire component
                el.innerHTML = text.replace(/\n/g, '<br>');

                saveHistory();
                // Update properties panel if this component is selected
                if (selectedComponent && selectedComponent.id === compId) {
                    showProperties(comp);
                }
            }
        }

        // Handle keyboard events in label editing
        function handleLabelKeydown(e, el) {
            // Shift+Enter for new line (default behavior)
            // Enter without shift to finish editing
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                disableTextEdit(el);
            }
            // Escape to cancel
            if (e.key === 'Escape') {
                e.preventDefault();
                const compId = el.dataset.compId;
                const comp = components.find(c => c.id === compId);
                if (comp) {
                    el.innerHTML = (comp.properties.text || '').replace(/\n/g, '<br>');
                }
                disableTextEdit(el);
            }
        }

        // Handle keyboard events in input editing (textbox, datepicker)
        function handleInputKeydown(e, el) {
            // Enter to finish editing
            if (e.key === 'Enter') {
                e.preventDefault();
                el.blur(); // This will trigger disableInputEdit
            }
            // Escape to cancel - just blur without saving
            if (e.key === 'Escape') {
                e.preventDefault();
                el.blur();
            }
        }

        // Handle keyboard events in select editing (dropdown)
        function handleSelectKeydown(e, el) {
            // Enter to finish editing
            if (e.key === 'Enter') {
                e.preventDefault();
                el.blur(); // This will trigger disableSelectEdit
            }
            // Escape to cancel
            if (e.key === 'Escape') {
                e.preventDefault();
                el.blur();
            }
        }

        // Handle keyboard events in button editing
        function handleButtonKeydown(e, el) {
            // Enter to finish editing (no multi-line for buttons)
            if (e.key === 'Enter') {
                e.preventDefault();
                el.blur();
            }
            // Escape to cancel
            if (e.key === 'Escape') {
                e.preventDefault();
                const compId = el.dataset.compId;
                const comp = components.find(c => c.id === compId);
                if (comp) {
                    el.textContent = comp.properties.text || 'Button';
                }
                el.blur();
            }
        }

        // Save button text
        function saveButtonText(el) {
            const compId = el.dataset.compId;
            const comp = components.find(c => c.id === compId);
            if (!comp) return;

            const text = el.textContent.trim();
            if (comp.properties.text !== text) {
                comp.properties.text = text;
                saveHistory();
                // Update properties panel if this component is selected
                if (selectedComponent && selectedComponent.id === compId) {
                    showProperties(comp);
                }
            }
        }

        function updateComponentElement(comp) {
            const el = document.getElementById(comp.id);
            if (!el) return;

            el.style.left = comp.x + 'px';
            el.style.top = comp.y + 'px';
            el.style.width = comp.width + 'px';
            el.style.height = comp.height + 'px';

            // Re-render inner HTML while preserving resize handles
            const handles = el.querySelectorAll('.resize-handle');
            el.innerHTML = getComponentHTML(comp);
            handles.forEach(h => el.appendChild(h.cloneNode(true)));

            // Re-attach resize handlers
            el.querySelectorAll('.resize-handle').forEach(handle => {
                const pos = handle.className.split(' ')[1];
                handle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    startResize(e, comp.id, pos);
                });
            });
        }

        // Context menu
        function showContextMenu(x, y) {
            contextMenu.style.left = x + 'px';
            contextMenu.style.top = y + 'px';
            contextMenu.classList.remove('hidden');
        }

        function duplicateComponent() {
            if (!selectedComponent) return;

            const newComp = JSON.parse(JSON.stringify(selectedComponent));
            newComp.id = `comp_${componentIdCounter++}`;
            newComp.x += 20;
            newComp.y += 20;

            components.push(newComp);
            renderComponent(newComp);
            selectComponent(newComp.id);
            saveHistory();
        }

        function deleteComponent() {
            if (!selectedComponent) return;

            const el = document.getElementById(selectedComponent.id);
            if (el) el.remove();

            components = components.filter(c => c.id !== selectedComponent.id);
            selectComponent(null);
            saveHistory();
        }

        // Delete all selected components
        function deleteSelectedComponents() {
            if (selectedComponents.length === 0) return;

            selectedComponents.forEach(comp => {
                const el = document.getElementById(comp.id);
                if (el) el.remove();
                components = components.filter(c => c.id !== comp.id);
            });

            clearSelection();
            saveHistory();
        }

        // Duplicate all selected components (Ctrl+D)
        function duplicateSelectedComponents() {
            if (selectedComponents.length === 0) return;

            const newComps = [];
            selectedComponents.forEach(comp => {
                const newComp = JSON.parse(JSON.stringify(comp));
                newComp.id = `comp_${componentIdCounter++}`;
                newComp.x += 20;
                newComp.y += 20;
                components.push(newComp);
                renderComponent(newComp);
                newComps.push(newComp);
            });

            // Select the new components
            selectMultipleComponents(newComps.map(c => c.id));
            saveHistory();
            showToast(`Duplicated ${newComps.length} component(s)`, 'success');
        }

        function bringToFront() {
            if (!selectedComponent) return;
            const el = document.getElementById(selectedComponent.id);
            if (el) {
                canvas.appendChild(el);
            }
        }

        function sendToBack() {
            if (!selectedComponent) return;
            const el = document.getElementById(selectedComponent.id);
            if (el) {
                canvas.insertBefore(el, canvas.firstChild);
            }
        }

        // History for undo/redo
        function saveHistory(skipDirty = false) {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.stringify(components));
            historyIndex = history.length - 1;

            // Limit history size
            if (history.length > 50) {
                history.shift();
                historyIndex--;
            }

            // Mark document as dirty (unless loading from file)
            if (!skipDirty && historyIndex > 0) {
                markDocumentDirty();
            }
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadFromHistory();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadFromHistory();
            }
        }

        function loadFromHistory() {
            components = JSON.parse(history[historyIndex]);
            rerenderCanvas();
        }

        function rerenderCanvas() {
            // Clear canvas
            canvas.querySelectorAll('.dropped-component').forEach(el => el.remove());

            // Re-render all components
            components.forEach(comp => renderComponent(comp));
            selectComponent(null);

            // Auto-resize canvas to fit all components
            autoResizeCanvas();
        }

        // Auto-resize canvas based on component positions
        function autoResizeCanvas() {
            const manualWidth = getCanvasWidth();
            const manualHeight = getCanvasHeight();

            let maxRight = manualWidth;
            let maxBottom = manualHeight;

            components.forEach(comp => {
                const right = comp.x + comp.width + 100;  // 100px padding
                const bottom = comp.y + comp.height + 100;

                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            canvas.style.width = maxRight + 'px';
            canvas.style.height = maxBottom + 'px';
            canvas.style.minWidth = maxRight + 'px';
            canvas.style.minHeight = maxBottom + 'px';

            // Update input fields if canvas expanded
            if (maxRight > manualWidth) {
                setCanvasWidthValue(Math.ceil(maxRight / 100) * 100);
            }
            if (maxBottom > manualHeight) {
                setCanvasHeightValue(Math.ceil(maxBottom / 100) * 100);
            }
        }

        // Manually set canvas size
        function setCanvasSize(showMessage = true) {
            const width = getCanvasWidth();
            const height = getCanvasHeight();

            canvas.style.width = Math.max(400, width) + 'px';
            canvas.style.height = Math.max(300, height) + 'px';
            canvas.style.minWidth = Math.max(400, width) + 'px';
            canvas.style.minHeight = Math.max(300, height) + 'px';

            // Redraw rulers if visible
            if (gridSettings.showRulers) {
                setTimeout(drawRulers, 0);
            }

            if (showMessage) {
                showToast(`Canvas size: ${width} x ${height}`, 'success');
            }
        }

        // Canvas resize drag functionality
        function initCanvasResize() {
            const resizeHandles = document.querySelectorAll('.canvas-resize-handle');
            let isResizingCanvas = false;
            let canvasResizeType = '';
            let canvasResizeStart = { x: 0, y: 0, width: 0, height: 0 };

            resizeHandles.forEach(handle => {
                handle.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    isResizingCanvas = true;
                    canvasResizeType = handle.dataset.resize;
                    canvasResizeStart = {
                        x: e.clientX,
                        y: e.clientY,
                        width: canvas.offsetWidth,
                        height: canvas.offsetHeight
                    };
                });
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizingCanvas) return;

                const dx = e.clientX - canvasResizeStart.x;
                const dy = e.clientY - canvasResizeStart.y;

                let newWidth = canvasResizeStart.width;
                let newHeight = canvasResizeStart.height;

                if (canvasResizeType.includes('e')) {
                    newWidth = Math.max(400, canvasResizeStart.width + dx);
                }
                if (canvasResizeType.includes('s')) {
                    newHeight = Math.max(300, canvasResizeStart.height + dy);
                }

                canvas.style.width = newWidth + 'px';
                canvas.style.height = newHeight + 'px';
                canvas.style.minWidth = newWidth + 'px';
                canvas.style.minHeight = newHeight + 'px';

                setCanvasWidthValue(newWidth);
                setCanvasHeightValue(newHeight);
            });

            document.addEventListener('mouseup', () => {
                if (isResizingCanvas) {
                    isResizingCanvas = false;
                    markDocumentDirty();
                    // Redraw rulers if visible
                    if (gridSettings.showRulers) {
                        drawRulers();
                    }
                }
            });
        }

        // Fit canvas to components (shrink to fit)
        function fitCanvasToComponents() {
            if (components.length === 0) {
                setCanvasWidthValue(1200);
                setCanvasHeightValue(800);
                setCanvasSize();
                return;
            }

            let maxRight = 0;
            let maxBottom = 0;

            components.forEach(comp => {
                const right = comp.x + comp.width + 50;
                const bottom = comp.y + comp.height + 50;

                if (right > maxRight) maxRight = right;
                if (bottom > maxBottom) maxBottom = bottom;
            });

            // Round up to nearest 100
            const newWidth = Math.max(400, Math.ceil(maxRight / 100) * 100);
            const newHeight = Math.max(300, Math.ceil(maxBottom / 100) * 100);

            setCanvasWidthValue(newWidth);
            setCanvasHeightValue(newHeight);

            setCanvasSize(false);
            markDocumentDirty();
            showToast(`Canvas fitted: ${newWidth} x ${newHeight}`, 'success');
        }

        // Save/Load JSON (legacy functions for compatibility)
        function saveDesign() {
            const design = {
                screenId: getScreenName(),
                screenTitle: getScreenTitle(),
                theme: currentTheme,
                canvasWidth: getCanvasWidth(),
                canvasHeight: getCanvasHeight(),
                components: components,
                version: '1.0',
                createdAt: new Date().toISOString()
            };

            const json = JSON.stringify(design, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `${design.screenId || 'screen'}.json`;
            a.click();

            URL.revokeObjectURL(url);
            showToast('Design saved successfully!', 'success');
        }

        // Legacy function - kept for compatibility
        function loadDesign() {
            docOpen();
        }

        // Legacy save function - kept for compatibility
        function saveDesign() {
            docSave();
        }

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            // Use new document system
            handleFileOpen(file);
            fileInput.value = '';
        });

        function exportImage() {
            // Use html2canvas if available, otherwise show message
            if (typeof html2canvas !== 'undefined') {
                // Hide resize handles and selection before export
                const resizeHandles = canvas.querySelectorAll('.resize-handle');
                const canvasResizeHandles = canvas.querySelectorAll('.canvas-resize-handle');
                const selectedComponents = canvas.querySelectorAll('.dropped-component.selected');
                const allComponents = canvas.querySelectorAll('.dropped-component');

                // Hide grid and rulers
                const gridOverlay = document.getElementById('gridOverlay');
                const rulerH = document.getElementById('rulerHorizontal');
                const rulerV = document.getElementById('rulerVertical');
                const rulerCorner = document.getElementById('rulerCorner');
                const marqueeEl = document.getElementById('marqueeSelection');

                const gridWasVisible = gridOverlay.classList.contains('visible');
                const rulersWereVisible = rulerH.classList.contains('visible');

                gridOverlay.classList.remove('visible');
                rulerH.classList.remove('visible');
                rulerV.classList.remove('visible');
                rulerCorner.classList.remove('visible');
                marqueeEl.style.display = 'none';

                // Store original states and hide handles
                resizeHandles.forEach(h => h.style.display = 'none');
                canvasResizeHandles.forEach(h => h.style.display = 'none');

                // Remove selection outline temporarily
                selectedComponents.forEach(c => c.classList.remove('selected'));

                // Remove hover outline by adding a temporary class
                allComponents.forEach(c => c.style.outline = 'none');

                // Also hide the dashed border of canvas
                const originalBorder = canvas.style.border;
                canvas.style.border = '1px solid #e2e8f0';

                // Remove rulers margin temporarily
                const hadRulersClass = canvas.classList.contains('with-rulers');
                canvas.classList.remove('with-rulers');

                html2canvas(canvas, {
                    backgroundColor: '#ffffff',
                    scale: 2 // Higher quality
                }).then(canvasEl => {
                    const link = document.createElement('a');
                    link.download = `${getScreenName() || 'screen'}.png`;
                    link.href = canvasEl.toDataURL();
                    link.click();

                    // Restore resize handles
                    resizeHandles.forEach(h => h.style.display = '');
                    canvasResizeHandles.forEach(h => h.style.display = '');

                    // Restore selection
                    selectedComponents.forEach(c => c.classList.add('selected'));

                    // Restore outline
                    allComponents.forEach(c => c.style.outline = '');

                    // Restore canvas border
                    canvas.style.border = originalBorder;

                    // Restore grid and rulers if they were visible
                    if (gridWasVisible) {
                        gridOverlay.classList.add('visible');
                    }
                    if (rulersWereVisible) {
                        rulerH.classList.add('visible');
                        rulerV.classList.add('visible');
                        rulerCorner.classList.add('visible');
                    }
                    if (hadRulersClass) {
                        canvas.classList.add('with-rulers');
                    }
                    marqueeEl.style.display = '';

                    showToast('PNG exported successfully!', 'success');
                });
            } else {
                showToast('For PNG export, please add html2canvas library', 'error');
            }
        }

        function clearCanvas() {
            if (confirm('Are you sure you want to clear all components?')) {
                components = [];
                rerenderCanvas();
                saveHistory();
                showToast('Canvas cleared', 'success');
            }
        }

        function showToast(message, type = 'info') {
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            document.body.appendChild(toast);

            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ============================================
        // Component Image Selection
        // ============================================

        let pendingImageComponentId = null;
        const componentImageInput = document.getElementById('componentImageInput');

        function selectImageForComponent(compId) {
            pendingImageComponentId = compId;
            componentImageInput.click();
        }

        componentImageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file || !pendingImageComponentId) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                const base64 = event.target.result;
                const comp = components.find(c => c.id === pendingImageComponentId);
                if (comp) {
                    comp.properties.src = base64;

                    // Auto-adjust size based on image dimensions
                    const img = new Image();
                    img.onload = () => {
                        // Keep aspect ratio, max 500px width
                        const maxWidth = 500;
                        const maxHeight = 400;
                        let newWidth = img.width;
                        let newHeight = img.height;

                        if (newWidth > maxWidth) {
                            newHeight = (maxWidth / newWidth) * newHeight;
                            newWidth = maxWidth;
                        }
                        if (newHeight > maxHeight) {
                            newWidth = (maxHeight / newHeight) * newWidth;
                            newHeight = maxHeight;
                        }

                        comp.width = Math.round(newWidth);
                        comp.height = Math.round(newHeight);

                        updateComponentElement(comp);
                        showProperties(comp);
                        saveHistory();
                        autoResizeCanvas();
                    };
                    img.src = base64;
                }
                pendingImageComponentId = null;
            };
            reader.readAsDataURL(file);
            componentImageInput.value = '';
        });

        // ============================================
        // Import from Image Feature
        // ============================================

        let selectedImageBase64 = null;

        // Load API key from localStorage
        function loadApiKey() {
            const saved = localStorage.getItem('anthropic_api_key');
            if (saved) {
                document.getElementById('apiKeyInput').value = saved;
            }
        }

        // Save API key to localStorage
        function saveApiKey(key) {
            localStorage.setItem('anthropic_api_key', key);
        }

        // Generate AI prompt from component properties (auto-sync with getDefaultProperties)
        function getAIPrompt() {
            // Get component types and their properties
            const componentTypes = ['label', 'title', 'textbox', 'textarea', 'datepicker', 'dropdown',
                                    'checkbox', 'radio', 'button', 'iconbutton', 'table', 'tabs',
                                    'panel', 'annotation', 'notebox', 'image'];

            // Property descriptions for AI (more detailed than defaults)
            const propDescriptions = {
                label: '{ text: string, fontSize: number (default 14), bold: boolean }',
                title: '{ text: string, fontSize: number (default 18) }',
                textbox: '{ placeholder: string, fieldName: string, required: boolean, width: number }',
                textarea: '{ placeholder: string, fieldName: string, rows: number }',
                datepicker: '{ placeholder: string (default "dd/mm/yyyy"), fieldName: string }',
                dropdown: '{ placeholder: string, options: string (comma-separated), fieldName: string }',
                checkbox: '{ label: string, fieldName: string, checked: boolean }',
                radio: '{ label: string, group: string, fieldName: string }',
                button: '{ text: string, style: "default"|"primary"|"success"|"danger", action: string }',
                iconbutton: '{ icon: "edit"|"delete"|"view"|"save"|"add"|"search"|"check"|"cancel"|"print"|"copy"|"refresh"|"download"|"upload"|"settings"|"user"|"calendar"|"filter"|"sort", iconType: "emoji"|"keenicons", tooltip: string, action: string }',
                table: '{ columns: string (comma-separated), rows: number, fieldName: string, cellTexts: 2D array of {text: string, bold: boolean, underline: boolean}, hasActionColumn: boolean, actionColumnPosition: "left"|"right", actionIcons: string (comma-separated), actionIconType: "emoji"|"keenicons" }',
                tabs: '{ tabs: string (comma-separated tab names), activeTab: number (index) }',
                panel: '{ title: string }',
                annotation: '{ text: string, direction: "left"|"right" }',
                notebox: '{ text: string }',
                image: '{ src: string (base64 or URL), alt: string, objectFit: "contain"|"cover"|"fill" }'
            };

            let propsText = componentTypes.map(type => `- ${type}: ${propDescriptions[type]}`).join('\n');

            return `Analyze this UI screenshot and generate a JSON array of UI components that can recreate this design.

Each component should have this structure:
{
  "id": "comp_N",
  "type": "${componentTypes.join('|')}",
  "x": number (position from left in pixels),
  "y": number (position from top in pixels),
  "width": number,
  "height": number,
  "properties": { type-specific properties }
}

Component types and their properties:
${propsText}

CRITICAL RULES - FOLLOW THESE EXACTLY:
1. Form fields with "label: input" pattern MUST be created as SEPARATE components:
   - Create a "label" component for the field name (left side)
   - Create a "textbox" or "datepicker" component for the input (right side)
   - DO NOT put form fields into a table!

2. Tab bars / Navigation tabs MUST use "tabs" component, NOT table

3. Use "table" component ONLY for actual data grids with multiple data rows (like spreadsheets, lists)

4. Date input fields (showing dates like dd/mm/yyyy) MUST use "datepicker" component

5. Progress bars or status bars should use "panel" component with colored title

6. Position components accurately - measure x, y positions carefully

7. Start component IDs from comp_1

8. Use Thai text if the screenshot contains Thai

9. Return ONLY valid JSON, no markdown or explanation

Example - Form with label and textbox:
  {"id":"comp_1","type":"label","x":20,"y":50,"width":100,"height":25,"properties":{"text":"‡∏ä‡∏∑‡πà‡∏≠:","fontSize":14,"bold":false}},
  {"id":"comp_2","type":"textbox","x":130,"y":50,"width":200,"height":36,"properties":{"placeholder":"","fieldName":"name"}}

Return format:
{
  "canvasWidth": number,
  "canvasHeight": number,
  "components": [...]
}`;
        }

        function showImportImageModal() {
            document.getElementById('importImageModal').classList.remove('hidden');
            loadApiKey();
            updateAnalyzeButton();
        }

        function closeImportImageModal() {
            document.getElementById('importImageModal').classList.add('hidden');
            document.getElementById('importStatus').style.display = 'none';
            // Reset image preview
            selectedImageBase64 = null;
            document.getElementById('imagePreviewContainer').style.display = 'none';
            document.getElementById('imagePlaceholder').style.display = 'block';
        }

        function updateAnalyzeButton() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            const btn = document.getElementById('analyzeBtn');
            btn.disabled = !apiKey || !selectedImageBase64;
        }

        // Image drop zone setup
        const imageDropZone = document.getElementById('imageDropZone');
        const imageInput = document.getElementById('imageInput');

        imageDropZone.addEventListener('click', () => imageInput.click());

        imageDropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageDropZone.style.borderColor = '#3b82f6';
            imageDropZone.style.background = '#eff6ff';
        });

        imageDropZone.addEventListener('dragleave', () => {
            imageDropZone.style.borderColor = '#cbd5e1';
            imageDropZone.style.background = '#f8fafc';
        });

        imageDropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            imageDropZone.style.borderColor = '#cbd5e1';
            imageDropZone.style.background = '#f8fafc';
            const file = e.dataTransfer.files[0];
            if (file && file.type.startsWith('image/')) {
                handleImageFile(file);
            }
        });

        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                handleImageFile(file);
            }
        });

        function handleImageFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64 = e.target.result;
                selectedImageBase64 = base64;

                // Show preview
                document.getElementById('imagePreview').src = base64;
                document.getElementById('imagePreviewContainer').style.display = 'block';
                document.getElementById('imagePlaceholder').style.display = 'none';

                updateAnalyzeButton();
            };
            reader.readAsDataURL(file);
        }

        document.getElementById('apiKeyInput').addEventListener('input', updateAnalyzeButton);

        async function analyzeImage() {
            const apiKey = document.getElementById('apiKeyInput').value.trim();
            if (!apiKey || !selectedImageBase64) {
                showToast('Please provide API key and image', 'error');
                return;
            }

            // Save API key
            saveApiKey(apiKey);

            // Show loading
            document.getElementById('importStatus').style.display = 'block';
            document.getElementById('analyzeBtn').disabled = true;

            try {
                // Extract base64 data (remove data:image/...;base64, prefix)
                const base64Data = selectedImageBase64.split(',')[1];
                const mediaType = selectedImageBase64.match(/data:(.*?);/)[1];

                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 8000,
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: mediaType,
                                        data: base64Data
                                    }
                                },
                                {
                                    type: 'text',
                                    text: getAIPrompt()
                                }
                            ]
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error?.message || 'API request failed');
                }

                const data = await response.json();
                const content = data.content[0].text;

                // Parse JSON from response
                let parsed;
                try {
                    // Try to extract JSON from the response
                    const jsonMatch = content.match(/\{[\s\S]*\}/);
                    if (jsonMatch) {
                        parsed = JSON.parse(jsonMatch[0]);
                    } else {
                        throw new Error('No JSON found in response');
                    }
                } catch (parseErr) {
                    console.error('Parse error:', content);
                    throw new Error('Failed to parse AI response as JSON');
                }

                // Load the components
                if (parsed.components && Array.isArray(parsed.components)) {
                    components = parsed.components;

                    // Update canvas size
                    if (parsed.canvasWidth) {
                        setCanvasWidthValue(parsed.canvasWidth);
                    }
                    if (parsed.canvasHeight) {
                        setCanvasHeightValue(parsed.canvasHeight);
                    }

                    // Find max component ID
                    componentIdCounter = 1;
                    components.forEach(c => {
                        const num = parseInt(c.id.replace('comp_', ''));
                        if (num >= componentIdCounter) componentIdCounter = num + 1;
                    });

                    rerenderCanvas();
                    saveHistory();

                    closeImportImageModal();
                    showToast(`Imported ${components.length} components from image!`, 'success');
                } else {
                    throw new Error('Invalid response format');
                }

            } catch (err) {
                console.error('Error:', err);
                showToast('Error: ' + err.message, 'error');
            } finally {
                document.getElementById('importStatus').style.display = 'none';
                updateAnalyzeButton();
            }
        }

        // Keyboard shortcuts for document operations
        document.addEventListener('keydown', (e) => {
            // Ctrl+N = New document
            if (e.ctrlKey && e.key === 'n') {
                e.preventDefault();
                newDocument();
            }
            // Ctrl+S = Save
            if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                if (e.shiftKey) {
                    docSaveAs();
                } else {
                    docSave();
                }
            }
            // Ctrl+O = Open
            if (e.ctrlKey && e.key === 'o') {
                e.preventDefault();
                docOpen();
            }
            // Ctrl+W = Close current tab
            if (e.ctrlKey && e.key === 'w') {
                e.preventDefault();
                const doc = getActiveDocument();
                if (doc) {
                    closeDocument(doc.id);
                }
            }
        });

        // Warn before closing browser if there are unsaved changes
        window.addEventListener('beforeunload', (e) => {
            const hasUnsaved = documents.some(doc => doc.isDirty);
            if (hasUnsaved) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
        });

        // Initialize
        initDocumentSystem();
        initCanvasResize();
        setCanvasSize(false);

        // Initialize rulers if default is on
        if (gridSettings.showRulers) {
            toggleRulers();
        }
    </script>

    <!-- Optional: Add html2canvas for PNG export -->
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</body>
</html>
